{"version":3,"file":"main.js","mappings":"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","sources":["webpack://ChiliEditorSDK/webpack/universalModuleDefinition","webpack://ChiliEditorSDK/webpack/bootstrap","webpack://ChiliEditorSDK/./node_modules/penpal/lib/enums.js","webpack://ChiliEditorSDK/webpack/runtime/define property getters","webpack://ChiliEditorSDK/webpack/runtime/hasOwnProperty shorthand","webpack://ChiliEditorSDK/webpack/runtime/make namespace object","webpack://ChiliEditorSDK/./node_modules/penpal/lib/createDestructor.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/parent/getOriginFromSrc.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/errorSerialization.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/generateId.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/methodSerialization.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/connectCallSender.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/parent/handleAckMessageFactory.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/connectCallReceiver.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/parent/connectToChild.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/createLogger.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/parent/handleSynMessageFactory.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/startConnectionTimeout.js","webpack://ChiliEditorSDK/./node_modules/penpal/lib/parent/monitorIframeRemoval.js","webpack://ChiliEditorSDK/./src/interactions/connector.ts","webpack://ChiliEditorSDK/./src/types/ConfigurationTypes.ts","webpack://ChiliEditorSDK/./src/types/DocumentTypes.ts","webpack://ChiliEditorSDK/./src/utils/EditorResponseData.ts","webpack://ChiliEditorSDK/./src/controllers/ActionController.ts","webpack://ChiliEditorSDK/./src/controllers/AnimationController.ts","webpack://ChiliEditorSDK/./src/controllers/CanvasController.ts","webpack://ChiliEditorSDK/./src/controllers/CharacterStyleController.ts","webpack://ChiliEditorSDK/./src/controllers/ColorStyleController.ts","webpack://ChiliEditorSDK/./src/controllers/ColorConversionController.ts","webpack://ChiliEditorSDK/./src/types/ConnectorTypes.ts","webpack://ChiliEditorSDK/./src/controllers/ConfigurationController.ts","webpack://ChiliEditorSDK/./src/controllers/ConnectorController.ts","webpack://ChiliEditorSDK/./src/controllers/DebugController.ts","webpack://ChiliEditorSDK/./src/types/FrameTypes.ts","webpack://ChiliEditorSDK/./src/controllers/DocumentController.ts","webpack://ChiliEditorSDK/./src/controllers/ExperimentController.ts","webpack://ChiliEditorSDK/./src/controllers/FontConnectorController.ts","webpack://ChiliEditorSDK/./src/controllers/FontController.ts","webpack://ChiliEditorSDK/./src/controllers/ShapeController.ts","webpack://ChiliEditorSDK/./src/controllers/FrameController.ts","webpack://ChiliEditorSDK/./src/controllers/LayoutController.ts","webpack://ChiliEditorSDK/./src/controllers/MediaConnectorController.ts","webpack://ChiliEditorSDK/./src/controllers/PageController.ts","webpack://ChiliEditorSDK/./src/controllers/ParagraphStyleController.ts","webpack://ChiliEditorSDK/./src/controllers/SubscriberController.ts","webpack://ChiliEditorSDK/./src/utils/enums.ts","webpack://ChiliEditorSDK/./src/controllers/TextStyleController.ts","webpack://ChiliEditorSDK/./src/controllers/ToolController.ts","webpack://ChiliEditorSDK/./src/controllers/UndoManagerController.ts","webpack://ChiliEditorSDK/./src/utils/MathUtils.ts","webpack://ChiliEditorSDK/./src/controllers/UtilsController.ts","webpack://ChiliEditorSDK/./src/controllers/VariableController.ts","webpack://ChiliEditorSDK/./src/controllers/InfoController.ts","webpack://ChiliEditorSDK/./src/sdk.ts","webpack://ChiliEditorSDK/./src/types/AnimationTypes.ts","webpack://ChiliEditorSDK/./src/types/LayoutTypes.ts","webpack://ChiliEditorSDK/./src/types/VariableTypes.ts","webpack://ChiliEditorSDK/./src/types/TextStyleTypes.ts","webpack://ChiliEditorSDK/./src/types/ColorStyleTypes.ts","webpack://ChiliEditorSDK/./src/types/MediaConnectorTypes.ts","webpack://ChiliEditorSDK/./src/types/FontConnectorTypes.ts","webpack://ChiliEditorSDK/./src/types/ActionTypes.ts","webpack://ChiliEditorSDK/./src/types/ShapeTypes.ts","webpack://ChiliEditorSDK/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ChiliEditorSDK\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ChiliEditorSDK\"] = factory();\n\telse\n\t\troot[\"ChiliEditorSDK\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (serializedMethods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, serializedMethods, childOrigin, originForSending) => {\n    return (event) => {\n        if (event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(serializedMethods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n","import { Connection, connectToChild } from 'penpal';\r\nimport { Id } from '../types/CommonTypes';\r\nimport { StudioStyling } from '../types/ConfigurationTypes';\r\n\r\nexport const validateEditorLink = (editorLink: string) => {\r\n    const linkValidator = new RegExp(/^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w.-]+)+[\\w]+\\/$/);\r\n    let link = '';\r\n    if (linkValidator.test(editorLink)) {\r\n        link = editorLink;\r\n    } else if (editorLink.indexOf('/index.html') > -1) {\r\n        link = editorLink.replace('/index.html', '/');\r\n    } else if (editorLink.charAt(-1) !== '/') {\r\n        link = `${editorLink}/`;\r\n    }\r\n    return link;\r\n};\r\n\r\nexport const setupFrame = (iframe: HTMLIFrameElement, editorLink: string, styling?: StudioStyling) => {\r\n    const link = validateEditorLink(editorLink);\r\n    const stylingJson = JSON.stringify(styling || {});\r\n    const html = `<html>\r\n    <head>\r\n      <base href=\"/\" />\r\n      <meta charset=\"UTF-8\"/>\r\n      <!--  use this property to pass the StudioStyling to the engine -->\r\n      <meta name=\"studio-styling\" content=${stylingJson}>\r\n    </head>\r\n    <body>\r\n    <script src=\"${link}init.js\" async></script>\r\n    <script src=\"${link}init_engine.js\"></script>\r\n    <script>\r\n        initializeStudioEngine({\r\n            assetBase: '${link}',\r\n            entryPointUrl: '${link}main.dart.js',\r\n        });\r\n    </script>\r\n    </body>\r\n    </html>\r\n    `;\r\n\r\n    // eslint-disable-next-line no-param-reassign\r\n    iframe.srcdoc = 'placeholder';\r\n\r\n    let iframeDoc: Document = iframe.ownerDocument;\r\n    if (iframe.contentWindow) {\r\n        iframeDoc = iframe.contentWindow.document;\r\n    }\r\n    iframeDoc.open();\r\n    iframeDoc.write(html);\r\n    iframeDoc.close();\r\n};\r\ninterface ConfigParameterTypes {\r\n    onActionsChanged: (state: string) => void;\r\n    onStateChanged: (state: string) => void;\r\n    onDocumentLoaded: () => void;\r\n    onSelectedFrameContentChanged: (state: string) => void;\r\n    onSelectedFrameLayoutChanged: (state: string) => void;\r\n    onSelectedLayoutPropertiesChanged: (state: string) => void;\r\n    onPageSelectionChanged: () => void;\r\n    onScrubberPositionChanged: (state: string) => void;\r\n    onFrameAnimationsChanged: (state: string) => void;\r\n    onVariableListChanged: (state: string) => void;\r\n    onSelectedToolChanged: (state: string) => void;\r\n    onUndoStateChanged: (state: string) => void;\r\n    onSelectedLayoutFramesChanged: (state: string) => void;\r\n    onSelectedTextStyleChanged: (styles: string) => void;\r\n    onColorsChanged: (colors: string) => void;\r\n    onParagraphStylesChanged: (paragraphStyles: string) => void;\r\n    onCharacterStylesChanged: (characterStyles: string) => void;\r\n    onFontFamiliesChanged: (fonts: string) => void;\r\n    onSelectedLayoutIdChanged: (id: string) => void;\r\n    onLayoutsChanged: (layouts: string) => void;\r\n    onConnectorEvent: (state: string) => void;\r\n    onZoomChanged: (scaleFactor: string) => void;\r\n    onPageSizeChanged: (scaleFactor: string) => void;\r\n    onShapeCornerRadiusChanged: (cornerRadius: string) => void;\r\n    onCropActiveFrameIdChanged: (id?: Id) => void;\r\n    onAsyncError: (asyncError: string) => void;\r\n}\r\n\r\nconst Connect = (\r\n    editorLink: string,\r\n    params: ConfigParameterTypes,\r\n    setConnection: (connection: Connection) => void,\r\n    editorId = 'chili-editor',\r\n    styling?: StudioStyling,\r\n) => {\r\n    const editorSelectorId = `#${editorId}`;\r\n    const iframe = document.createElement('iframe');\r\n    iframe.setAttribute('srcdoc', ' ');\r\n    iframe.setAttribute('title', 'Chili-Editor');\r\n    iframe.setAttribute('style', 'width: 100%; height: 100%;');\r\n    iframe.setAttribute('frameBorder', '0');\r\n    iframe.setAttribute('referrerpolicy', 'origin');\r\n\r\n    const setupNewFrame = () => {\r\n        const iframeContainer = document.querySelector(editorSelectorId);\r\n        if (iframeContainer) {\r\n            iframeContainer?.appendChild(iframe);\r\n            setupFrame(iframe, editorLink, styling);\r\n        }\r\n    };\r\n\r\n    if (document.readyState === 'complete' || document.readyState === 'interactive') {\r\n        setupNewFrame();\r\n    } else {\r\n        document.addEventListener('DOMContentLoaded', () => {\r\n            setupNewFrame();\r\n        });\r\n    }\r\n    setConnection(\r\n        connectToChild({\r\n            // The iframe to which a connection should be made\r\n            iframe,\r\n            // All the methods that we want to expose to the child should be inside the methods object\r\n            // f.e. stateChange(documentJson)\r\n            methods: {\r\n                actionsChanged: params.onActionsChanged,\r\n                stateChanged: params.onStateChanged,\r\n                documentLoaded: params.onDocumentLoaded,\r\n                selectedFrameContent: params.onSelectedFrameContentChanged,\r\n                selectedFrameLayout: params.onSelectedFrameLayoutChanged,\r\n                selectedLayoutProperties: params.onSelectedLayoutPropertiesChanged,\r\n                openLayoutPropertiesPanel: params.onPageSelectionChanged,\r\n                scrubberPositionChanged: params.onScrubberPositionChanged,\r\n                frameAnimationsChanged: params.onFrameAnimationsChanged,\r\n                selectedToolChanged: params.onSelectedToolChanged,\r\n                variableListChanged: params.onVariableListChanged,\r\n                undoStackStateChanged: params.onUndoStateChanged,\r\n                selectedLayoutFramesChanged: params.onSelectedLayoutFramesChanged,\r\n                selectedTextStyleChanged: params.onSelectedTextStyleChanged,\r\n                colorsChanged: params.onColorsChanged,\r\n                paragraphStylesChanged: params.onParagraphStylesChanged,\r\n                characterStylesChanged: params.onCharacterStylesChanged,\r\n                fontFamiliesChanged: params.onFontFamiliesChanged,\r\n                selectedLayoutId: params.onSelectedLayoutIdChanged,\r\n                layoutListChanged: params.onLayoutsChanged,\r\n                connectorEvent: params.onConnectorEvent,\r\n                zoomChanged: params.onZoomChanged,\r\n                pageSizeChanged: params.onPageSizeChanged,\r\n                shapeCornerRadiusChanged: params.onShapeCornerRadiusChanged,\r\n                cropActiveFrameIdChanged: params.onCropActiveFrameIdChanged,\r\n                asyncError: params.onAsyncError,\r\n            },\r\n        }),\r\n    );\r\n};\r\nexport default Connect;\r\n","export enum WellKnownConfigurationKeys {\r\n    GraFxStudioEnvironmentApiUrl = 'ENVIRONMENT_API',\r\n    GraFxStudioSdkVersion = 'SDK_VERSION',\r\n    GraFxStudioDocumentType = 'DOCUMENT_TYPE',\r\n    GraFxStudioTemplateId = 'TEMPLATE_ID',\r\n    GraFxStudioAuthToken = 'GRAFX_AUTH_TOKEN',\r\n}\r\n\r\nexport type StudioStyling = {\r\n    uiBackgroundColorHex?: string;\r\n};\r\n\r\n/**\r\n * Studio Options that can be updated.\r\n */\r\nexport type StudioOptionsDeltaUpdate = {\r\n    /** Options for the different studio engine shortcuts */\r\n    shortcutOptions?: ShortcutOptionsDeltaUpdate;\r\n};\r\n\r\n/**\r\n * Shortcut Options that can be updated.\r\n */\r\nexport type ShortcutOptionsDeltaUpdate = {\r\n    /** The debug panel shortcut. */\r\n    debugPanel?: ShortcutOption;\r\n\r\n    /** The ellipse shape shortcut. */\r\n    ellipse?: ShortcutOption;\r\n\r\n    /** The hand shortcut. */\r\n    hand?: ShortcutOption;\r\n\r\n    /** The image frame shortcut. */\r\n    image?: ShortcutOption;\r\n\r\n    /** The polygon shape shortcut. */\r\n    polygon?: ShortcutOption;\r\n\r\n    /** The rectangle shape shortcut. */\r\n    rectangle?: ShortcutOption;\r\n\r\n    /** The select shortcut. */\r\n    select?: ShortcutOption;\r\n\r\n    /** The text frame shortcut. */\r\n    text?: ShortcutOption;\r\n\r\n    /** The zoom shortcut. */\r\n    zoom?: ShortcutOption;\r\n};\r\n\r\n/**\r\n * Specific shortcut options\r\n */\r\nexport type ShortcutOption = {\r\n    /** Whether the shortcut is enabled. */\r\n    enabled: boolean;\r\n};\r\n\r\n/**\r\n * Default studio options with all shortcuts disabled.\r\n */\r\nexport const defaultStudioOptions: StudioOptionsDeltaUpdate = {\r\n    shortcutOptions: {\r\n        debugPanel: { enabled: false },\r\n        ellipse: { enabled: false },\r\n        hand: { enabled: false },\r\n        image: { enabled: false },\r\n        polygon: { enabled: false },\r\n        rectangle: { enabled: false },\r\n        select: { enabled: false },\r\n        text: { enabled: false },\r\n        zoom: { enabled: false },\r\n    },\r\n};\r\n","import { BasicAnimationsEmphasisType, BasicAnimationsIntroType, BasicAnimationsOutroType } from './AnimationTypes';\r\nimport { DocumentColor } from './ColorStyleTypes';\r\nimport { Id } from './CommonTypes';\r\nimport { BlendMode, FrameTypeEnum } from './FrameTypes';\r\nimport { LayoutType } from './LayoutTypes';\r\nimport { ParagraphStyle } from './ParagraphStyleTypes';\r\nimport { Variable } from './VariableTypes';\r\nimport { CharacterStyle } from './CharacterStyleTypes';\r\nimport { DocumentAction } from './ActionTypes';\r\nimport { ShapeProperties } from './ShapeTypes';\r\n\r\nexport type DocumentError = { error: Record<string, unknown>; code: number };\r\n\r\nexport type UndoState = {\r\n    canUndo: boolean;\r\n    canRedo: boolean;\r\n    undoItemName: OperationName;\r\n    redoItemName: OperationName;\r\n};\r\n\r\nexport type OperationName = { translationKey: number; name: string };\r\n\r\n/**\r\n * This type should give a clear indication of how the JSON document is structured. This could help you with building a test document yourself.\r\n */\r\nexport interface ChiliDocument {\r\n    selectedLayoutId: string;\r\n    properties?: TemplateDocumentProperties | ProjectDocumentProperties;\r\n    pages: DocumentPage[];\r\n    layouts: (ChildLayout | TopLayout)[];\r\n    stylekit: DocumentStylekit;\r\n    variables: Variable[];\r\n    actions: DocumentAction[];\r\n}\r\n\r\nexport interface DocumentPage {\r\n    id: string;\r\n    number: number;\r\n    frames: (ImageFrame | TextFrame | ShapeFrame)[];\r\n}\r\n\r\nexport interface DocumentFrame {\r\n    id: string;\r\n    name: string;\r\n    type: FrameTypeEnum;\r\n    blendMode: BlendMode;\r\n    constrainProportions: boolean;\r\n}\r\n\r\nexport interface ImageFrame extends DocumentFrame {\r\n    src: ImageFrameUrlSource | ImageFrameConnectorSource | ImageFrameVariableSource;\r\n}\r\n\r\nexport interface ShapeFrame extends DocumentFrame {\r\n    shapeProperties: ShapeProperties;\r\n}\r\n\r\nexport interface TextFrame extends DocumentFrame {\r\n    textContent: string;\r\n    paddingLeft: number;\r\n    paddingTop: number;\r\n    paddingRight: number;\r\n    paddingBottom: number;\r\n    numberOfColumns: number;\r\n    columnGap: number;\r\n    textDirection: string;\r\n    flowDirection: string;\r\n    verticalAlign: string;\r\n    textStroke: boolean;\r\n    textStrokeWeight: number;\r\n    textStrokeColor: number;\r\n    hasClippingPath: boolean;\r\n}\r\n\r\nexport enum ImageFrameSourceType {\r\n    url = 'url',\r\n    assetProvider = 'assetProvider',\r\n    variable = 'variable',\r\n}\r\n\r\nexport interface ImageFrameSource {\r\n    type: ImageFrameSourceType;\r\n}\r\n\r\nexport interface ImageFrameUrlSource extends ImageFrameSource {\r\n    url: string;\r\n}\r\n\r\nexport interface ImageFrameConnectorSource extends ImageFrameSource {\r\n    id: string;\r\n    assetId: string;\r\n}\r\n\r\nexport interface ImageFrameVariableSource extends ImageFrameSource {\r\n    id: string;\r\n}\r\n\r\nexport interface Layout {\r\n    id: string;\r\n    name: string;\r\n    frameProperties: (ChildFrameProperty | TopFrameProperty)[];\r\n    width?: number;\r\n    height?: number;\r\n    childLayouts: string[];\r\n    type: LayoutType;\r\n    frameAnimations?: FrameAnimation[];\r\n    timelineLengthMs?: number;\r\n    animated?: boolean;\r\n}\r\n\r\nexport interface TopLayout extends Layout {\r\n    frameAnimations: FrameAnimation[];\r\n    timelineLengthMs: number;\r\n    animated: boolean;\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport interface ChildLayout extends Layout {\r\n    parentId: Id;\r\n}\r\n\r\nexport enum FramePropertiesType {\r\n    top = 'top',\r\n    child = 'child',\r\n}\r\nexport interface FrameProperty {\r\n    id: Id;\r\n    x?: number;\r\n    y?: number;\r\n    width?: number;\r\n    height?: number;\r\n    rotationDegrees?: number;\r\n    rotationOriginY?: number;\r\n    scaleX?: number;\r\n    scaleY?: number;\r\n    isVisible?: boolean;\r\n    type: FramePropertiesType;\r\n}\r\n\r\nexport type ChildFrameProperty = FrameProperty;\r\nexport interface TopFrameProperty extends FrameProperty {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    rotationDegrees: number;\r\n    rotationOriginY: number;\r\n    scaleX: number;\r\n    scaleY: number;\r\n    isVisible: boolean;\r\n}\r\n\r\nexport interface FrameAnimation {\r\n    id: Id;\r\n    from: number;\r\n    to: number;\r\n    basicAnimations: BasicAnimations;\r\n}\r\n\r\nexport interface BasicAnimations {\r\n    intro?: BasicAnimationsIntroType;\r\n    emphasis?: BasicAnimationsEmphasisType;\r\n    outro?: BasicAnimationsOutroType;\r\n}\r\n\r\nexport interface DocumentStylekit {\r\n    colors: DocumentColor[];\r\n    characterStyles: DocumentCharacterStyle[];\r\n    paragraphStyles: DocumentParagraphStyle[];\r\n}\r\n\r\nexport type DocumentCharacterStyle = CharacterStyle;\r\nexport type DocumentParagraphStyle = ParagraphStyle;\r\n\r\nexport interface DocumentVariable extends Variable {\r\n    parentId: Id;\r\n    name: string;\r\n    label: string;\r\n    isVisible: boolean;\r\n    isReadonly: boolean;\r\n    isRequired: boolean;\r\n    value: string;\r\n    defaultValue: string;\r\n}\r\n\r\nexport enum DocumentType {\r\n    project = 'project',\r\n    template = 'template',\r\n}\r\n\r\nexport interface DocumentProperties {\r\n    type: DocumentType;\r\n}\r\n\r\nexport type TemplateDocumentProperties = DocumentProperties;\r\n\r\nexport interface ProjectDocumentProperties extends DocumentProperties {\r\n    templateId: string;\r\n}\r\n\r\nexport type DocumentLoadOptions = {\r\n    keepConnectors?: boolean;\r\n};","import type { EditorResponse } from '../types/CommonTypes';\r\n\r\nexport function getEditorResponseData<T>(response: EditorResponse<unknown>, parse = true): EditorResponse<T> {\r\n    try {\r\n        if (!response.success) {\r\n            throw new Error(response.error ?? 'Yikes, something went wrong', {\r\n                cause: {\r\n                    name: String(response.status),\r\n                    message: response.error ?? 'Yikes, something went wrong',\r\n                },\r\n            });\r\n        }\r\n        const dataShouldBeParsed = response.data && parse;\r\n        return {\r\n            ...response,\r\n            parsedData: dataShouldBeParsed\r\n                ? (JSON.parse(response.data as string) as T)\r\n                : (response.data as unknown as T),\r\n        };\r\n    } catch (error) {\r\n        console.error(error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// For testing purposes only\r\nexport function castToEditorResponse(toCast: unknown): EditorResponse<unknown> {\r\n    return {\r\n        status: 200,\r\n        success: true,\r\n        parsedData: null,\r\n        data: JSON.stringify(toCast),\r\n    };\r\n}\r\n","import { ActionTrigger, DocumentAction } from '../types/ActionTypes';\r\nimport { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The ActionController is responsible for all Actions-related functionality.\r\n * Methods inside this controller can be called by `window.SDK.action.{method-name}`\r\n */\r\nexport class ActionController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of all actions.\r\n     * @returns list of all actions\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getActions().then((result) => getEditorResponseData<DocumentAction[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns an action by the id\r\n     * @param id the id of a specific action\r\n     * @returns action details\r\n     */\r\n    getById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getActionById(id).then((result) => getEditorResponseData<DocumentAction>(result));\r\n    };\r\n\r\n    /**\r\n     * This method creates a new action.\r\n     * @returns the id of the newly created action.\r\n     */\r\n    create = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.createAction().then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method duplicates an existing action by the id\r\n     * @param id the id of a specific action\r\n     * @returns the id of the duplicated action.\r\n     */\r\n    duplicate = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.duplicateAction(id).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes the action by the id\r\n     * @param id the id of a specific action\r\n     * @returns\r\n     */\r\n    remove = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeAction(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method renames an action by the id and provided name\r\n     * @param id the id of a specific action\r\n     * @param name the new unique name for the action\r\n     * @returns\r\n     */\r\n    rename = async (id: Id, name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.renameAction(id, name).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method updates the script the action uses by the id and provided script\r\n     * @param id the id of a specific action\r\n     * @param actionScript the JavaScript based action script\r\n     * @returns\r\n     */\r\n    updateScript = async (id: Id, actionScript: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.updateActionScript(id, actionScript).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method updates the triggers on which the action will react.\r\n     * @param id the id of a specific action\r\n     * @param triggers the triggers this action should react on.\r\n     * @returns\r\n     */\r\n    updateTriggers = async (id: Id, triggers: ActionTrigger[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .updateActionTriggers(id, JSON.stringify(triggers))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method changes positions of actions\r\n     * @param order the position of actions\r\n     * @param ids the list of action IDs\r\n     * @returns\r\n     */\r\n    move = async (order: number, ids: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.moveActions(order, ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method stores the state of action type errors to the document\r\n     * \r\n     * Those errors states can be read back from the usual getters or the\r\n     * `onActionsChanged` stream\r\n     * @param id the id of a specific action\r\n     * @param hasTypeErrors whether there is an action type error\r\n     * @returns\r\n     */\r\n    setTypeError = async (id: string, hasTypeErrors: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setActionTypeError(id, hasTypeErrors).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { FrameAnimationPropertiesType } from '../types/AnimationTypes';\r\nimport { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The AnimationController is responsible for all communication regarding Animations.\r\n * Methods inside this controller can be called by `window.SDK.animation.{method-name}`\r\n */\r\nexport class AnimationController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(children: EditorAPI) {\r\n        this.#editorAPI = children;\r\n    }\r\n\r\n    /**\r\n     * This method returns all animations on current layout\r\n     * @returns list of all animation on current layout\r\n     */\r\n    getAllOnSelectedLayout = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getAnimationsOnSelectedLayout()\r\n            .then((result) => getEditorResponseData<FrameAnimationPropertiesType[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns an animation for a given frame and layout IDs\r\n     * @param id the id of a specific frame\r\n     * @param layoutId the id of a specific layout\r\n     * @returns animation properties for a given frame and layout\r\n     */\r\n    getByFrameId = async (id: Id, layoutId?: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getAnimationByFrameId<string>(id, layoutId)\r\n            .then((result) => getEditorResponseData<FrameAnimationPropertiesType>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the animations for a given layout id\r\n     * @param id the id of a specific layout\r\n     * @returns animation properties for a given layout\r\n     */\r\n    getByLayoutId = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getAnimationsByLayoutId(id)\r\n            .then((result) => getEditorResponseData<FrameAnimationPropertiesType>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the animation state for a certain Frame\r\n     * @param animation animation properties\r\n     * @returns updated animation properties\r\n     */\r\n    setFrameAnimation = async (animation: FrameAnimationPropertiesType) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameAnimation(JSON.stringify(animation))\r\n            .then((result) =>\r\n                getEditorResponseData<FrameAnimationPropertiesType>({ ...result, data: JSON.stringify(animation) }),\r\n            );\r\n    };\r\n\r\n    /**\r\n     * This method triggers the animation to play\r\n     * @returns\r\n     */\r\n    play = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.playAnimation().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method triggers the animation to pause\r\n     * @returns\r\n     */\r\n    pause = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.pauseAnimation().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the animation time to a certain time, expressed in milliseconds\r\n     * @param timeInMS the time expressed in milliseconds\r\n     * @returns\r\n     */\r\n    setScrubberPosition = async (timeInMS: number) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setScrubberPosition(timeInMS).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the total and maximum duration of the animation, expressed in milliseconds\r\n     * @param timeInMS the time expressed in milliseconds\r\n     * @returns\r\n     */\r\n    setDuration = async (timeInMS: number) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setAnimationDuration(timeInMS).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method resets the animation to its initial state\r\n     * @param id the id of a certain frame\r\n     * @returns\r\n     */\r\n    resetFrameAnimation = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameAnimation(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method resets the layout's animations and animation duration to its initial state\r\n     * @returns\r\n     */\r\n    reset = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetAnimation().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The CanvasController is responsible for all Canvas-related functionality.\r\n * Methods inside this controller can be called by `window.SDK.canvas.{method-name}`\r\n */\r\nexport class CanvasController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method fits the page to the given rectangle or the viewport available\r\n     * Optional parameters `left`, `top`, `width` and `height` are needed to define the rectangle to fit the page to\r\n     * If any or all of them aren't provided the page will fit the whole viewport available\r\n     * @param id the id of a specific page\r\n     * @param left\r\n     * @param top\r\n     * @param width\r\n     * @param height\r\n     * @returns\r\n     */\r\n    zoomToPage = async (\r\n        id?: Id | null,\r\n        left?: number | null,\r\n        top?: number | null,\r\n        width?: number | null,\r\n        height?: number | null,\r\n    ) => {\r\n        const res = await this.#editorAPI;\r\n        return res.zoomToPage(id, left, top, width, height).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method gets the scale factor of the canvas\r\n     * @returns scale factor in percents\r\n     */\r\n    getZoomPercentage = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getZoomPercentage().then((result) => getEditorResponseData<number>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the scale factor to the canvas and re-centers the page\r\n     * @param scaleFactor scale factor in percents\r\n     * @returns\r\n     */\r\n    setZoomPercentage = async (scaleFactor: number) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setZoomPercentage(scaleFactor).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { CharacterStyle, CharacterStyleUpdate } from '../types/CharacterStyleTypes';\r\n\r\n/**\r\n * The CharacterStyleController is responsible for all communication regarding character styles.\r\n * Methods inside this controller can be called by `window.SDK.characterStyle.{method-name}`\r\n */\r\nexport class CharacterStyleController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of character styles\r\n     * @returns list of all character styles\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getCharacterStyles().then((result) => getEditorResponseData<CharacterStyle[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a character style by the id\r\n     * @param characterStyleId the id of a specific character style\r\n     * @returns character style for given id\r\n     */\r\n    getById = async (characterStyleId: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getCharacterStyleById(characterStyleId)\r\n            .then((result) => getEditorResponseData<CharacterStyle>(result));\r\n    };\r\n\r\n    /**\r\n     * This method creates a new character style\r\n     * @returns the id of new character style\r\n     */\r\n    create = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.createCharacterStyle().then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method updates a character style by the id and provided properties\r\n     * @param characterStyleId the id of a specific character style\r\n     * @param characterStyle the new character style properties\r\n     * @returns\r\n     */\r\n    update = async (characterStyleId: Id, characterStyle: CharacterStyleUpdate) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .updateCharacterStyle(characterStyleId, JSON.stringify(characterStyle))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a character style by the id\r\n     * @param characterStyleId the id of a specific character style\r\n     * @returns\r\n     */\r\n    remove = async (characterStyleId: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeCharacterStyle(characterStyleId).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method duplicates a character style by the id\r\n     * @param characterStyleId the id of a specific character style\r\n     * @returns id of the duplicated character style\r\n     */\r\n    duplicate = async (characterStyleId: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.duplicateCharacterStyle(characterStyleId).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method renames a character style by the id\r\n     * @param characterStyleId the id of a specific character style\r\n     * @param characterStyleName the new name of the character style\r\n     * @returns\r\n     */\r\n    rename = async (characterStyleId: Id, characterStyleName: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.renameCharacterStyle(characterStyleId, characterStyleName).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { ColorUpdate, DocumentColor } from '../types/ColorStyleTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The ColorStyleController is responsible for all communication regarding color styles.\r\n * Methods inside this controller can be called by `window.SDK.colorStyle.{method-name}`\r\n */\r\nexport class ColorStyleController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of colors\r\n     * @returns list of all colors\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getColors().then((result) => getEditorResponseData<DocumentColor[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a color by id\r\n     * @param id the id of a specific color\r\n     * @returns color properties for given id\r\n     */\r\n    getById = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getColorById(id).then((result) => getEditorResponseData<DocumentColor>(result));\r\n    };\r\n\r\n    /**\r\n     * This method creates a new color\r\n     * @returns the new created color id\r\n     */\r\n    create = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.createColor().then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method duplicates a color by the id\r\n     * @param id the id of a specific color\r\n     * @returns id of the duplicated color\r\n     */\r\n    duplicate = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.duplicateColor(id).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method changes positions of colors\r\n     * @param order the position of the colors\r\n     * @param ids the list of color IDs\r\n     * @returns\r\n     */\r\n    move = async (order: number, ids: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.moveColors(order, ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method renames a color\r\n     * @param id the id of a specific color\r\n     * @param newColorName the new name of the color\r\n     * @returns\r\n     */\r\n    rename = async (id: string, newColorName: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.renameColor(id, newColorName).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method updates a color\r\n     * @param id the id of a specific color\r\n     * @param newColorProperties the new color properties\r\n     * @returns\r\n     */\r\n    update = async (id: string, newColorProperties: ColorUpdate) => {\r\n        const res = await this.#editorAPI;\r\n        return res.updateColor(id, JSON.stringify(newColorProperties)).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a color\r\n     * @param id the id of a specific color\r\n     * @returns\r\n     */\r\n    remove = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeColor(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { Color, RGBColor } from '../types/ColorStyleTypes';\r\n\r\n/**\r\n * The ColorConversionController is responsible for all communication regarding color coversion.\r\n * Methods inside this controller can be called by `window.SDK.colorConversion.{method-name}`\r\n */\r\nexport class ColorConversionController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method converts the given color to its rgb representation\r\n     * @param color the color to convert\r\n     * @returns the rgb representation of the given color\r\n     */\r\n    convertToRgb = async (color: Color) => {\r\n        const res = await this.#editorAPI;\r\n        return res.colorToRgb(color).then((result) => getEditorResponseData<RGBColor>(result));\r\n    };\r\n\r\n}\r\n","import { Id } from './CommonTypes';\r\n\r\nexport enum DeprecatedMediaType {\r\n    file = 0,\r\n    collection = 1,\r\n}\r\n\r\nexport enum MediaType {\r\n    file = 'file',\r\n    collection = 'collection',\r\n}\r\n\r\nexport enum ConnectorType {\r\n    media = 'media',\r\n    fonts = 'fonts',\r\n}\r\n\r\nexport enum SortBy {\r\n    name = 'name',\r\n    path = 'relativePath',\r\n    id = 'id',\r\n}\r\n\r\nexport enum SortOrder {\r\n    ascending = 'asc',\r\n    descending = 'desc',\r\n}\r\n\r\nexport type QueryOptions = {\r\n    filter?: string[] | null;\r\n    collection?: string | null;\r\n    pageToken?: string | null;\r\n    pageSize?: number | null;\r\n    sortBy?: SortBy | null;\r\n    sortOrder?: SortOrder | null;\r\n};\r\n\r\nexport type ConnectorCapabilities = {\r\n    filtering?: boolean;\r\n    upload?: boolean;\r\n    query?: boolean;\r\n    remove?: boolean;\r\n    copy?: boolean;\r\n    detail?: boolean;\r\n};\r\n\r\ninterface ConnectorRegistrationBase {\r\n    /**\r\n     * Url to the connector.\r\n     *\r\n     * - If source is `url`, this must be a publicly available url.\r\n     *\r\n     * - If source is `grafx`, this must be the full url to the connector GET endpoint on GraFx Environment API.\r\n     */\r\n    url: string;\r\n\r\n    /**\r\n     * Connector source type.\r\n     */\r\n    source: ConnectorRegistrationSource;\r\n};\r\n\r\nexport interface ConnectorUrlRegistration extends ConnectorRegistrationBase {\r\n    source: ConnectorRegistrationSource.url;\r\n}\r\n\r\nexport interface ConnectorGrafxRegistration extends ConnectorRegistrationBase {\r\n    source: ConnectorRegistrationSource.grafx;\r\n}\r\n\r\nexport interface ConnectorLocalRegistration extends ConnectorRegistrationBase {\r\n    source: ConnectorRegistrationSource.local;\r\n}\r\n\r\nexport type ConnectorRegistration = ConnectorUrlRegistration | ConnectorGrafxRegistration | ConnectorLocalRegistration;\r\n\r\nexport type ConnectorInstance = {\r\n    id: Id;\r\n    name: string;\r\n    iconUrl: string;\r\n    source: ConnectorRegistration;\r\n};\r\n\r\nexport enum ConnectorRegistrationSource {\r\n    /**\r\n     * Connector is hosted on a publicly available link.\r\n     */\r\n    url = 'url',\r\n\r\n    /**\r\n     * Connector is hosted on GraFx Environment API.\r\n     */\r\n    grafx = 'grafx',\r\n\r\n    /**\r\n     * Connector is embedded in the document.\r\n     * Note: This is a temporary type; only to be used internally.\r\n     */\r\n    local = 'local',\r\n}\r\n\r\nexport class ConnectorMapping {\r\n    name: string;\r\n    value: string;\r\n\r\n    constructor(contextProperty: string, mapFrom: ConnectorMappingSource, sourceValue: string) {\r\n        this.name = contextProperty;\r\n\r\n        if (mapFrom === ConnectorMappingSource.variable) {\r\n            this.value = `${mapFrom}.${sourceValue}`;\r\n        } else {\r\n            this.value = sourceValue;\r\n        }\r\n    }\r\n}\r\n\r\nexport type ConnectorState = {\r\n    id: Id;\r\n    type: ConnectorStateType;\r\n};\r\n\r\nexport type ConnectorEvent = {\r\n    id: Id;\r\n    type: ConnectorEventType;\r\n};\r\n\r\nexport type QueryPage<T> = {\r\n    nextPageToken?: string;\r\n    data: T[];\r\n};\r\n\r\nexport enum ConnectorMappingSource {\r\n    variable = 'var',\r\n    value = 'value',\r\n}\r\n\r\nexport enum ConnectorStateType {\r\n    /**\r\n     * Connector loading process has started.\r\n     * Any SDK methods that required the connector id, will start working now.\r\n     */\r\n    loading = 'loading',\r\n\r\n    /**\r\n     * Connector loading completed.\r\n     */\r\n    loaded = 'loaded',\r\n\r\n    /**\r\n     * Connector is running in QuickJS.\r\n     */\r\n\r\n    running = 'running',\r\n\r\n    /**\r\n     * Connector is fully configured and has the correct authentication information.\r\n     * At this point the connector is ready to make requests.\r\n     */\r\n    ready = 'ready',\r\n\r\n    /**\r\n     * Something went wrong, the connector is in error state.\r\n     * Check the error message for more information.\r\n     */\r\n    error = 'error',\r\n}\r\n\r\nexport enum ConnectorEventType {\r\n    /**\r\n     * This event will be triggered by the following state changes of the connector\r\n     * - loading\r\n     * - loaded\r\n     * - running\r\n     * - ready\r\n     * - error\r\n     */\r\n    stateChanged = 'stateChanged',\r\n\r\n    /**\r\n     * Authentication information is changed\r\n     */\r\n    authChanged = 'authChanged',\r\n\r\n    /**\r\n     * Connector configuration changed that requires the connector to be reloaded in QuickJS.\r\n     * This will trigger multiple 'stateChanged' events while it is reloading.\r\n     * Wait until 'ready'-stateChanged event is received to start using the connector again.\r\n     */\r\n    reloadRequired = 'reloadRequired',\r\n\r\n    /**\r\n     * Connector is unregistered and no longer exists inside the editor engine.\r\n     * Don't use the 'connectorId' after receiving this event.\r\n     */\r\n    unloaded = 'unloaded',\r\n}\r\n\r\n/**\r\n * Hardcoded grafx media connector until we get it from the environment.\r\n */\r\nexport const grafxMediaConnectorRegistration: ConnectorLocalRegistration = {\r\n    url: 'grafx-media.json',\r\n    source: ConnectorRegistrationSource.local,\r\n}\r\n","import { EditorAPI } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { StudioOptionsDeltaUpdate, WellKnownConfigurationKeys } from '../types/ConfigurationTypes';\r\n\r\n/**\r\n * The ConfigurationController allows setting editor session data. This data is not stored in the document and\r\n * can only be used at runtime. Amongst others, the configuration store is available to the editor connectors and\r\n * Javascript actions running in the editor.\r\n * Methods inside this controller can be called by `window.SDK.configuration.{method-name}`\r\n */\r\nexport class ConfigurationController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the value for a given configuration key. If a value was not found in the configuration store\r\n     * this method returns an error. The key cannot be null.\r\n     * @returns value for a given configuration key\r\n     */\r\n    getValue = async (key: WellKnownConfigurationKeys | string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getConfigValue(key).then((result) => getEditorResponseData<string>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets, or overrides the value for a given key. Null values are not allowed for both key and value,\r\n     * using them will result in an error.\r\n     * @returns\r\n     */\r\n    setValue = async (key: WellKnownConfigurationKeys | string, value: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setConfigValue(key, value).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method updates the studio options. Only defined options are updated, null values are ignored.\r\n     * @returns\r\n     */\r\n    updateStudioOptions = async (options: StudioOptionsDeltaUpdate) => {\r\n        const res = await this.#editorAPI;\r\n        return res.updateStudioOptions(JSON.stringify(options)).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { ConnectorOptions, EditorAPI, EditorResponse, Id } from '../types/CommonTypes';\r\nimport {\r\n    ConnectorState,\r\n    ConnectorStateType,\r\n    ConnectorMapping,\r\n    ConnectorRegistration,\r\n    ConnectorInstance,\r\n    ConnectorType,\r\n} from '../types/ConnectorTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The ConnectorController manages lifetime of all available connectors, regardless of the type, in the\r\n * document. Use it to add/remove connectors to a template, or set specific configuration.\r\n *\r\n * The way CHILI Studio handles different sources of resources is called 'Connectors'. A Connectors is an\r\n * implementation of a set of capabilities we need to interact with a certain external resource management system.\r\n * In essence a connector is the combination of a Javascript snippet and some metadata. The Javascript snippet\r\n * is loaded in the studio engine using a sandboxed Javascript execution engine (QuickJs). This allows us to\r\n * execute the media connector both on web using webassembly and on the server side during e.g. animation output\r\n * generation.\r\n * This controller is an interface to the running connector instance inside the studio engine. The engine will\r\n * automatically register the 'grafx-media' and 'grafx-font' connectors. Custom connectors need to be registered\r\n * manually.\r\n */\r\nexport class ConnectorController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * Gets a connector by its id\r\n     * @param id the id of the connector\r\n     * @returns connector\r\n     */\r\n    getById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getConnectorById(id).then((result) => getEditorResponseData<ConnectorInstance>(result));\r\n    };\r\n\r\n    /**\r\n     * Gets all available connectors of a 'ConnectorType'\r\n     * @param type type of connector you want to get\r\n     * @returns list of all available connectors of a 'ConnectorType'\r\n     */\r\n    getAllByType = async (type: ConnectorType) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getConnectors(type).then((result) => getEditorResponseData<ConnectorInstance[]>(result));\r\n    };\r\n\r\n    /**\r\n     * Registers a new connector in the SDK. After successful registration, depending\r\n     * on the connector type, the connector can be configured and used in the template\r\n     * Remember to add custom authentication information after registering the connector\r\n     * @param registration registration object containing all details about the connector\r\n     * @returns the Id of the newly created connector, this Id should be used going forward.\r\n     */\r\n    register = async (registration: ConnectorRegistration) => {\r\n        const res = await this.#editorAPI;\r\n        return res.registerConnector(JSON.stringify(registration)).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * Unregisters a connector from the document.\r\n     * @param id the id of the connector to unregister\r\n     * @returns\r\n     */\r\n    unregister = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.unregisterConnector(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Configures a registered connector. A configurator helper is passed as an argument\r\n     * of the callback for you to setup your connector.\r\n     * @param id the id of your registered connector\r\n     * @param configurationCallback callback to setup the connector\r\n     * @returns\r\n     */\r\n    configure = async (id: Id, configurationCallback: (configurator: ConnectorConfigurator) => Promise<void>) => {\r\n        const res = await this.#editorAPI;\r\n        // wait for connector to be ready\r\n        await this.waitToBeReady(id);\r\n        // execute callback\r\n        await configurationCallback(new ConnectorConfigurator(id, res));\r\n        // invalidate connector in engine\r\n        return res.updateConnectorConfiguration(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Gets the current state a connector is in, to wait until a connector is ready to be used, use the 'waitToBeReady'\r\n     * method in this controller.\r\n     * @param id the id of your registered connector you want to make sure it is loaded\r\n     * @returns connector state\r\n     */\r\n    getState = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getConnectorState(id).then((result) => getEditorResponseData<ConnectorState>(result));\r\n    };\r\n\r\n    /**\r\n     * Gets the mapped data from connector.\r\n     * @param id the id of your registered connector\r\n     * @returns mappings\r\n     */\r\n    getMappings = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getConnectorMappings(id).then((result) => getEditorResponseData<ConnectorMapping[]>(result));\r\n    };\r\n\r\n    /**\r\n    * Gets the options from the connector.\r\n    * @param id the id of your registered connector\r\n    * @returns options\r\n    */\r\n    getOptions = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getConnectorOptions(id).then((result) => getEditorResponseData<ConnectorOptions>(result));\r\n    };\r\n\r\n    /**\r\n     * Connectors are loaded asynchronously in the editor engine, this causes some challenges while configuring them. To make sure\r\n     * an action on the connector will be available, it's advised to await this method. After the Promise resolves we are sure\r\n     * the connector is up and running. This is used internally by the configure method to ensure correct execution. It's especially\r\n     * useful during startup of the SDK / right after the loadDocument call.\r\n     * @param id the id of your registered connector you want to make sure it is loaded\r\n     * @returns\r\n     */\r\n    waitToBeReady = async (id: Id, timeoutMilliseconds = 2000): Promise<EditorResponse<null>> => {\r\n        // minimum timeout is 500ms\r\n        let timeout = Math.max(timeoutMilliseconds, 500);\r\n\r\n        // maximum timeout is 5000ms\r\n        timeout = Math.min(timeout, 5000);\r\n\r\n        const waitTime = 100;\r\n        let retries = 0;\r\n\r\n        try {\r\n            // using while loop will prevent stack overflow issues when using recursion\r\n            // wait for maximum 2 seconds to fail\r\n            while (retries * waitTime < timeout) {\r\n                const result = await this.getState(id);\r\n\r\n                if (\r\n                    result.success &&\r\n                    result.parsedData &&\r\n                    (result.parsedData.type === ConnectorStateType.running ||\r\n                        result.parsedData.type === ConnectorStateType.ready)\r\n                ) {\r\n                    return getEditorResponseData<null>(\r\n                        { data: null, success: true, error: undefined, status: 0, parsedData: undefined },\r\n                        false,\r\n                    );\r\n                }\r\n\r\n                await new Promise((resolve) => setTimeout(resolve, waitTime));\r\n                retries++;\r\n            }\r\n        } catch (err) {\r\n            return getEditorResponseData<null>(\r\n                {\r\n                    data: null,\r\n                    success: false,\r\n                    error: `Error while getting connector state ${err}`,\r\n                    status: 50000,\r\n                    parsedData: undefined,\r\n                },\r\n                false,\r\n            );\r\n        }\r\n\r\n        return getEditorResponseData<null>(\r\n            {\r\n                data: null,\r\n                success: false,\r\n                error: `Timed out waiting for connector`,\r\n                status: 50000,\r\n                parsedData: undefined,\r\n            },\r\n            false,\r\n        );\r\n    };\r\n}\r\n\r\n/**\r\n * Helper to setup your connector\r\n */\r\nclass ConnectorConfigurator {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #connectorId: Id;\r\n    #res: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(id: Id, res: EditorAPI) {\r\n        this.#connectorId = id;\r\n        this.#res = res;\r\n    }\r\n\r\n    /**\r\n     * Allows to customize the context data a connector can work with. The options data\r\n     * will be available using the context parameter in the connector implementation code.\r\n     * @param options object containing key value data to pass to connector context\r\n     * @returns\r\n     */\r\n    setOptions = async (options: ConnectorOptions) => {\r\n        return this.#res\r\n            .setConnectorOptions(this.#connectorId, JSON.stringify(options))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Allows to map document data (variables, selectedFrame, etc) to connector context data.\r\n     * By defining the mappings, we can trigger re-download of assets (dynamic asset provider)\r\n     * or populate filters for the query endpoint. The mapped data will be available using\r\n     * the context parameter in the connector implementation code.\r\n     * @param mappings collection of mappings to set to this connector\r\n     * @returns\r\n     */\r\n    setMappings = async (mappings: ConnectorMapping[]) => {\r\n        const result = await this.#res.setConnectorMappings(\r\n            this.#connectorId,\r\n            mappings.map(function (m) {\r\n                return JSON.stringify(m);\r\n            }),\r\n        );\r\n        return getEditorResponseData<null>(result);\r\n    };\r\n\r\n    /**\r\n     * @deprecated define the GraFx Studio Auth Token in the `SDK.Configuration.setValue`\r\n     *\r\n     * This method sets the GraFx Access Token in the Authentication HTTP header for the 'chili' authentication type.\r\n     * The CHILI Token will be used to authenticate every grafx connector http call.\r\n     * @param token token for the CHILI authentication\r\n     * @returns\r\n     */\r\n    setChiliToken = async (token: string) => {\r\n        return this.#res\r\n            .connectorAuthenticationSetChiliToken(this.#connectorId, token)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the HTTP headers for the 'staticKey' authentication type.\r\n     * These additional headers will be added to all connector http calls.\r\n     * Can only be used after a connector has been registered. (if you are using a grafx connector no registration is needed)\r\n     * @param headerName name of the header\r\n     * @param headerValue value of the header\r\n     * @returns\r\n     */\r\n    setHttpHeader = async (headerName: string, headerValue: string) => {\r\n        return this.#res\r\n            .connectorAuthenticationSetHttpHeader(this.#connectorId, headerName, headerValue)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { DebugData } from '../types/DebugTypes';\r\n\r\n/**\r\n * The DebugController is responsible for all communication regarding Debugging.\r\n * Methods inside this controller can be called by `window.SDK.debug.{method-name}`\r\n */\r\nexport class DebugController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns all debug logs\r\n     * @returns list of all debug logs\r\n     */\r\n    getAllLogs = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getLogs().then((result) => getEditorResponseData<DebugData[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method toggles the showcase of debug panel\r\n     * @returns\r\n     */\r\n    toggleDebugPanel = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.toggleDebugPanel().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method enables the debugging\r\n     * @returns\r\n     */\r\n    enableDebug = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.enableDebug().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method disables the debugging\r\n     * @returns\r\n     */\r\n    disableDebug = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.disableDebug().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","// FramePropertiesDto\r\nimport { ColorUsage } from './ColorStyleTypes';\r\nimport { Id, PropertyState } from './CommonTypes';\r\nimport { CornerRadiusAll, CornerRadiusNone, CornerRadiusOnly, ShapeType } from './ShapeTypes';\r\n\r\nexport type FrameLayoutType = {\r\n    id: Id;\r\n    layoutId: Id;\r\n    x: PropertyState<number>;\r\n    y: PropertyState<number>;\r\n    width: PropertyState<number>;\r\n    height: PropertyState<number>;\r\n    rotationDegrees: PropertyState<number>;\r\n    scaleX: PropertyState<number>;\r\n    scaleY: PropertyState<number>;\r\n    isVisible: PropertyState<boolean>;\r\n    fitMode: PropertyState<FitMode>;\r\n    hasImageCrop: PropertyState<boolean>;\r\n    minCopyfitting: PropertyState<number>;\r\n    maxCopyfitting: PropertyState<number>;\r\n    enableCopyfitting: PropertyState<boolean>;\r\n} | null;\r\n\r\n//Frame.image\r\nexport type FrameType = {\r\n    id: Id;\r\n    name: string;\r\n    type: FrameTypeEnum;\r\n    // `imageUrl` is not generic: should be removed from model\r\n    imageUrl: string;\r\n    blendMode: string;\r\n    constrainProportions: boolean;\r\n};\r\n\r\nexport type Frame = TextFrame | ImageFrame | ShapeFrame;\r\n\r\nexport type ImageFrameVariableSource = {\r\n    type: ImageSourceTypeEnum.variable;\r\n    id: Id;\r\n};\r\n\r\nexport type ImageFrameUrlSource = {\r\n    type: ImageSourceTypeEnum.url;\r\n    url: string;\r\n};\r\n\r\nexport type ImageFrameConnectorSource = {\r\n    assetId: Id;\r\n    id: Id;\r\n    type: ImageSourceTypeEnum.connector;\r\n};\r\n\r\nexport type ImageFrameSource = ImageFrameConnectorSource | ImageFrameVariableSource | ImageFrameUrlSource;\r\n\r\n// used by new getter methods\r\nexport type ImageFrame = {\r\n    id: Id;\r\n    name: string;\r\n    type: FrameTypeEnum.image;\r\n    src?: ImageFrameSource;\r\n    blendMode: BlendMode;\r\n    constrainProportions: boolean;\r\n    crop?: CropSettings | NoCropSettings;\r\n};\r\n\r\nexport type ShapeFrame = {\r\n    id: Id;\r\n    name: string;\r\n    type: FrameTypeEnum.shape;\r\n    blendMode: BlendMode;\r\n    constrainProportions: boolean;\r\n    shapeProperties: {\r\n        enableFill: boolean;\r\n        fillColor: ColorUsage;\r\n        enableStroke: boolean;\r\n        strokeWeight: number;\r\n        strokeColor: ColorUsage;\r\n        allCornersSame: boolean;\r\n    };\r\n    src: {\r\n        type: ShapeType;\r\n        cornerRadius: CornerRadiusNone | CornerRadiusAll | CornerRadiusOnly;\r\n        sides?: number;\r\n    };\r\n};\r\n\r\nexport type TextFrame = {\r\n    id: Id;\r\n    name: string;\r\n    type: FrameTypeEnum.text;\r\n    textContent: string;\r\n    paddingLeft: number;\r\n    paddingTop: number;\r\n    paddingRight: number;\r\n    paddingBottom: number;\r\n    numberOfColumn: number;\r\n    columnGap: number;\r\n    textDirection: TextDirection;\r\n    flowDirection: FlowDirection;\r\n    verticalAlign: VerticalAlign;\r\n    textStroke: boolean;\r\n    textStrokeWeight: number;\r\n    textStrokeColor: number;\r\n    hasClippingPath: boolean;\r\n    blendMode: BlendMode;\r\n    constrainProportions: boolean;\r\n};\r\n\r\nexport type CropSettings = {\r\n    left: number;\r\n    top: number;\r\n    width: number;\r\n    height: number;\r\n    rotationDegrees: number;\r\n    type: 'default';\r\n};\r\n\r\nexport type NoCropSettings = {\r\n    type: 'noCrop';\r\n};\r\n\r\nexport enum ImageSourceTypeEnum {\r\n    url = 'url',\r\n    variable = 'variable',\r\n    connector = 'connector',\r\n}\r\n\r\nexport enum FrameTypeEnum {\r\n    text = 'text',\r\n    image = 'image',\r\n    shape = 'shape',\r\n}\r\n\r\nexport enum TextDirection {\r\n    leftToRight = 'leftToRight',\r\n    rightToLeft = 'rightToLeft',\r\n    weak = 'weak',\r\n}\r\n\r\nexport enum FlowDirection {\r\n    horizontal = 'horizontal',\r\n    vertical = 'vertical',\r\n    onPath = 'onPath',\r\n}\r\n\r\nexport enum VerticalAlign {\r\n    top = 'top',\r\n    bottom = 'bottom',\r\n    middle = 'middle',\r\n    justify = 'justify',\r\n}\r\n\r\nexport enum BlendMode {\r\n    normal = 'normal',\r\n    screen = 'screen',\r\n    overlay = 'overlay',\r\n    darken = 'darken',\r\n    lighten = 'lighten',\r\n    colorDodge = 'colorDodge',\r\n    colorBurn = 'colorBurn',\r\n    hardLight = 'hardLight',\r\n    softLight = 'softLight',\r\n    difference = 'difference',\r\n    exclusion = 'exclusion',\r\n    multiply = 'multiply',\r\n    hue = 'hue',\r\n    saturation = 'saturation',\r\n    color = 'color',\r\n    luminosity = 'luminosity',\r\n}\r\n\r\nexport enum FitMode {\r\n    fit = 'fit',\r\n    fill = 'fill',\r\n}\r\n\r\nexport enum UpdateZIndexMethod {\r\n    bringToFront = 'bringToFront',\r\n    sendToBack = 'sendToBack',\r\n    bringForward = 'bringForward',\r\n    sendBackward = 'sendBackward',\r\n}\r\n","import { EditorAPI } from '../types/CommonTypes';\r\nimport type { ChiliDocument, DocumentLoadOptions } from '../types/DocumentTypes';\r\n\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n/**\r\n * The DocumentController is responsible for all communication regarding the Document.\r\n * Methods inside this controller can be called by `window.SDK.document.{method-name}`\r\n */\r\n\r\nexport class DocumentController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method retrieves the current document state from the editor\r\n     * @returns the JSON document in the form of a string\r\n     */\r\n    getCurrentState = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getCurrentDocumentState().then((result) => getEditorResponseData<ChiliDocument>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will load a provided document in the ChiliDocument format and\r\n     * clean old document states.\r\n     * If you set `DocumentLoadOptions.keepConnectors` to true, `load` will keep\r\n     * your old connectors states e.g. options, authentication..\r\n     * By default `keepConnectors` is false and your connectors states are reset.\r\n     * In this case, you would need to configure your connectors appropriately\r\n     * beforehand.\r\n     * @param doc the document to load in\r\n     * @param options the options object for setting up the document load\r\n     * @returns the document loaded inside of the canvas\r\n     */\r\n    load = async (doc: ChiliDocument | string, options: DocumentLoadOptions = { keepConnectors: false }) => {\r\n        const res = await this.#editorAPI;\r\n\r\n        // Note: loadDocumentKeepConnectors is a temporary engine call to make the\r\n        // merging smoother, it will be removed when all projects will point to\r\n        // this SDK version but the SDK API won't change. -> [EDT-1107]\r\n        const loadDocumentRedirection = options.keepConnectors ? res.loadDocumentKeepConnectors : res.loadDocument;\r\n        const parsedDoc = typeof doc !== 'string' ? JSON.stringify(doc) : doc;\r\n\r\n        return loadDocumentRedirection(parsedDoc).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { ImageSourceTypeEnum, ImageFrameVariableSource } from '../types/FrameTypes';\r\nimport { TextType } from '../types/TextTypes';\r\n\r\n/**\r\n * The ExperimentController contains all SDK functions that are considered for addition,\r\n * or functions we want to keep open for changing definitions. This is a sneak peak\r\n * into future versions of the SDK. Never build production code relying on functions in\r\n * this controller.\r\n */\r\nexport class ExperimentController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method will assign an image from a variable to the correct ImageFrame\r\n     * @param imageFrameId the id of the imageFrame where an image needs to be assigned to\r\n     * @param variableId the id of the variable which contains the image\r\n     * @returns\r\n     */\r\n    insertImageVariableToFrame = async (imageFrameId: Id, variableId: Id) => {\r\n        const res = await this.#editorAPI;\r\n        const src: ImageFrameVariableSource = { id: variableId, type: ImageSourceTypeEnum.variable };\r\n        return res\r\n            .setImageSource(imageFrameId, JSON.stringify(src))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will insert a text variable in the selected frame. Calling this method\r\n     * requires that the selected frame is in text editing mode.\r\n     * @param id the id of the variable to be inserted.\r\n     * @returns\r\n     */\r\n    insertTextVariable = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.insertTextVariable(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will enter text editing mode on the provided frame.\r\n     * @param id the id frame to enter text edit mode on.\r\n     * @returns\r\n     */\r\n    enterTextEditMode = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.enterTextEditMode(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will exit text editing mode.\r\n     * @returns\r\n     */\r\n    exitTextEditMode = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.exitTextEditMode().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method gets the text content of a text frame.\r\n     * The variables contained in the text will return their values only if you\r\n     * are in text editing mode.\r\n     * @param frameId The ID of a text frame\r\n     * @param textType The type of the text\r\n     * @returns the text content\r\n     */\r\n    getText = async (frameId: string, textType: TextType) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getTextByFrameId(frameId, textType).then((result) => getEditorResponseData<string>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the text content of a text frame\r\n     * @param frameId The ID of a text frame\r\n     * @param text The new text content\r\n     * @returns\r\n     */\r\n    setText = async (frameId: string, text: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setTextByFrameId(frameId, text).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method selects the text content of a text frame\r\n     * @param frameId The ID of a text frame\r\n     * @param startIndex The index where the selection starts\r\n     * @param length The length of selection from startIndex\r\n     * @returns\r\n     */\r\n    selectText = async (frameId: string, startIndex: number, length: number) => {\r\n        const res = await this.#editorAPI;\r\n        return res.selectTextById(frameId, startIndex, length).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { ConnectorConfigOptions, EditorAPI, EditorRawAPI, EditorResponse, MetaData } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport {\r\n    ConnectorCapabilities,\r\n    DeprecatedMediaType,\r\n    MediaType,\r\n    QueryOptions,\r\n    QueryPage,\r\n} from '../types/ConnectorTypes';\r\nimport { FontFamily, FontPreviewFormat, FontStyle } from '../types/FontConnectorTypes';\r\nimport { CallSender } from 'penpal';\r\n\r\n/**\r\n * The FontConnectorController is responsible for all communication regarding Font connectors.\r\n * Methods inside this controller can be called by `window.SDK.FontConnector.{method-name}`\r\n *\r\n * The way CHILI Studio handles different sources of Font is called 'FontConnectors'. A FontConnectors is an\r\n * implementation of a set of capabilities we need to interact with a certain Digital Asset Management system.\r\n * In essence a connector is the combination of a Javascript snippet and some metadata. The Javascript snippet\r\n * is loaded in the studio engine using a sandboxed Javascript execution engine (QuickJs). This allows us to\r\n * execute the Font connector both on web using webassembly and on the server side during e.g. animation output\r\n * generation.\r\n * This controller is an interface to the running connector instance inside the studio engine.\r\n */\r\nexport class FontConnectorController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n    #blobAPI: EditorRawAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n        this.#blobAPI = editorAPI as CallSender as EditorRawAPI;\r\n    }\r\n\r\n    /**\r\n     * Query a specific FontConnector for data using both standardized queryOptions and the dynamic\r\n     * context as parameters.\r\n     * @param connectorId unique id of the Font connector\r\n     * @param queryOptions query options\r\n     * @param context context that will be available in the connector script.\r\n     * @returns array of font families\r\n     */\r\n    query = async (connectorId: string, queryOptions: QueryOptions, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorQuery(connectorId, JSON.stringify(queryOptions), JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<QueryPage<FontFamily>>(result));\r\n    };\r\n\r\n    /**\r\n     * Returns all font styles for a family using a specific FontConnector. The connector needs to list `detail` as a supported capability.\r\n     * @param connectorId unique id of the Font connector\r\n     * @param fontFamilyId unique id of the Font family\r\n     * @param context context that will be available in the connector script.\r\n     * @returns array of font styles\r\n     */\r\n    detail = async (connectorId: string, fontFamilyId: string, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorDetail(connectorId, fontFamilyId, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<FontStyle[]>(result));\r\n    };\r\n\r\n    /**\r\n     * The combination of a `connectorId` and `fontId` is typically enough for a Font connector to\r\n     * perform the download of this asset. The `download` endpoint is capable of relaying this information to the\r\n     * Font connector instance running in the editor engine.\r\n     * @param connectorId unique id of the Font connector\r\n     * @param fontStyleId unique id of the Font style to download\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    download = async (connectorId: string, fontStyleId: string, context: MetaData = {}): Promise<Uint8Array> => {\r\n        const res = await this.#blobAPI;\r\n        return res\r\n            .fontConnectorDownload(connectorId, fontStyleId, JSON.stringify(context))\r\n            .then((result) => (result as Uint8Array) ?? (result as EditorResponse<null>));\r\n    };\r\n\r\n    /**\r\n     * The combination of a `connectorId` and `fontFamilyId` is typically enough for a Font connector to\r\n     * perform the preview of this asset. The `preview` endpoint is capable of relaying this information to the\r\n     * Font connector instance running in the editor engine.\r\n     * @param connectorId unique id of the Font connector\r\n     * @param fontFamilyId unique id of the Font family to download\r\n     * @param previewFormat hint to the Font connector about desired format of the Font preview\r\n     * @param context dynamic map of additional options potentially used by the connector\r\n     * @returns\r\n     */\r\n    preview = async (\r\n        connectorId: string,\r\n        fontFamilyId: string,\r\n        previewFormat: FontPreviewFormat,\r\n        context: MetaData = {},\r\n    ): Promise<Uint8Array> => {\r\n        const res = await this.#blobAPI;\r\n        return res\r\n            .fontConnectorPreview(connectorId, fontFamilyId, previewFormat, JSON.stringify(context))\r\n            .then((result) => (result as Uint8Array) ?? (result as EditorResponse<null>));\r\n    };\r\n\r\n    /**\r\n     * Depending on the connector capabilities, this api method allows you to upload new Font to the\r\n     * connector's backend.\r\n     * @param connectorId unique id of the Font connector\r\n     * @param fontStyleId unique id of the Font style to upload\r\n     * @param blob byte array representation of the Font to upload\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    upload = async (connectorId: string, fontStyleId: string, blob: Uint8Array, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorUpload(connectorId, fontStyleId, blob, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Depending on the connector capabilities, removes Font identified by `fontId` from the connector's backend storage\r\n     * @param connectorId unique id of the Font connector\r\n     * @param fontStyleId unique id of the Font style to remove\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    remove = async (connectorId: string, fontStyleId: string, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorRemove(connectorId, fontStyleId, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Depending on the connector capabilities, copies Font identified by `fontId` to a new Font item on the\r\n     * connector's backend\r\n     * @param connectorId unique id of the Font connector\r\n     * @param fontStyleId unique id of the Font to download\r\n     * @param newName name of the copied Font on the connector's backend\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    copy = async (connectorId: string, fontStyleId: string, newName: string, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorCopy(connectorId, fontStyleId, newName, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * All connectors have a certain set of mappings they allow to be passed into the connector methods their context. This\r\n     * method allows you to discover which mappings are available for a given connector. If you want to use any of these\r\n     * mappings, they will be available in the `context` parameter of any connector method.\r\n     * @param connectorId unique id of the media connector\r\n     * @returns connector mappings\r\n     */\r\n    getConfigurationOptions = async (connectorId: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorGetConfigurationOptions(connectorId)\r\n            .then((result) => getEditorResponseData<ConnectorConfigOptions>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns what capabilities the selected connector has. It gives an indication what methods can\r\n     * be used successfully for a certain connector.\r\n     * @param connectorId unique id of the Font connector\r\n     * @returns connector capabilities\r\n     */\r\n    getCapabilities = async (connectorId: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .fontConnectorGetCapabilities(connectorId)\r\n            .then((result) => getEditorResponseData<ConnectorCapabilities>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will parse the deprecatedFontType to the new Font type. This method will be removed once the deprecatedFontType is out of use\r\n     * @param deprecatedType is 0 or 1\r\n     * @returns MediaType value\r\n     */\r\n    parseDeprecatedFontType = (deprecatedType: DeprecatedMediaType) => {\r\n        if (deprecatedType === DeprecatedMediaType.file) return MediaType.file;\r\n        if (deprecatedType === DeprecatedMediaType.collection) return MediaType.collection;\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { AddDocumentFontFamily, AddDocumentFontStyle, DocumentFontFamily, DocumentFontStyle } from '../types/FontTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The FontController is responsible for all communication regarding font styles.\r\n * Methods inside this controller can be called by `window.SDK.font.{method-name}`\r\n */\r\nexport class FontController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method adds a font family\r\n     * @param connectorId unique id of the font connector\r\n     * @param fontFamily the font family object\r\n     * @returns id generated on the engine side `CONNECTOR_ID::FONT_FAMILY_ID`\r\n     */\r\n    addFontFamily = async (connectorId: Id, fontFamily: AddDocumentFontFamily) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .addFontFamily(connectorId, JSON.stringify(fontFamily))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a font family\r\n     * @param id the id of a specific font family\r\n     * @returns\r\n     */\r\n    removeFontFamily = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeFontFamily(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method adds a font style\r\n     * @param connectorId unique id of the font connector\r\n     * @param fontStyle the font object\r\n     * @returns id generated on the engine side `CONNECTOR_ID::FONT_FAMILY_ID::FONT_STYLE_ID`\r\n     */\r\n    addFontStyle = async (connectorId: Id, fontStyle: AddDocumentFontStyle) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .addFontStyle(connectorId, JSON.stringify(fontStyle))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a font style\r\n     * @param id the id of a specific font style\r\n     * @returns\r\n     */\r\n    removeFontStyle = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeFontStyle(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the list of font families\r\n     * @returns DocumentFontFamily[]\r\n     */\r\n    getFontFamilies = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFontFamilies().then((result) => getEditorResponseData<DocumentFontFamily[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the list of font styles for a specific family\r\n     * @param id the id of a specific font style\r\n     * @returns DocumentFontStyle[]\r\n     */\r\n    getFontStyles = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFontStyles(id).then((result) => getEditorResponseData<DocumentFontStyle[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a font family by id\r\n     * @param id the id of a specific font family\r\n     * @returns DocumentFontFamily properties\r\n     */\r\n    getFontFamilyById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFontFamilyById(id).then((result) => getEditorResponseData<DocumentFontFamily>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a font style by id\r\n     * @param id the id of a specific font style\r\n     * @returns DocumentFontStyle properties\r\n     */\r\n    getFontStyleById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFontStyleById(id).then((result) => getEditorResponseData<DocumentFontStyle>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the default font.\r\n     * Be aware that the default font will not change during the entire lifetime of the SDK session.\r\n     * It is not necessary to call this more than once in an integration, this value can be safely stored during the lifetime of this SDK session.\r\n     * @returns DocumentFontStyle properties\r\n     */\r\n    getDefaultFontStyle = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getDefaultFontStyle().then((result) => getEditorResponseData<DocumentFontStyle>(result));\r\n    };\r\n\r\n    /**\r\n     * Check if the font family is used anywhere in the document\r\n     * @param id the id of the font family to check\r\n     * @returns boolean\r\n     */\r\n    isFontFamilyUsed = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.isFontFamilyUsed(id).then((result) => getEditorResponseData<boolean>(result));\r\n    };\r\n\r\n    /**\r\n     * Check if the font style is used anywhere in the document\r\n     * @param id the id of the font style to check\r\n     * @returns boolean\r\n     */\r\n    isFontStyleUsed = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.isFontStyleUsed(id).then((result) => getEditorResponseData<boolean>(result));\r\n    };\r\n\r\n    /**\r\n     * This method changes positions of font families\r\n     * @param order the position of the font family\r\n     * @param ids the list of font family  IDs\r\n     * @returns\r\n     */\r\n    moveFontFamilies = async (order: number, ids: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.moveFontFamilies(order, ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { ColorUsage } from '../types/ColorStyleTypes';\r\nimport { CornerRadiusUpdateModel, ShapeProperties } from '../types/ShapeTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The ShapeController is responsible for all communication regarding Shapes.\r\n * Methods inside this controller can be called by `window.SDK.shape.{method-name}`\r\n */\r\nexport class ShapeController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method updates properties of the shape\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param properties A property to update\r\n     * @returns\r\n     */\r\n    private setShapeProperties = async (id: Id, properties: ShapeProperties) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setShapeProperties(id, JSON.stringify(properties))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the visibility of the shape fill.\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param enableFill Whether the shape fill is visible.\r\n     * @returns\r\n     */\r\n    setEnableFill = async (id: Id, enableFill: boolean) => {\r\n        const properties: ShapeProperties = { enableFill: enableFill };\r\n        return this.setShapeProperties(id, properties);\r\n    };\r\n\r\n    /**\r\n     * This method will set the shape fill color of a specified shape frame.\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param fillColor the new shape fill color that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setFillColor = async (id: Id, fillColor: ColorUsage) => {\r\n        const properties: ShapeProperties = { fillColor: fillColor };\r\n        return this.setShapeProperties(id, properties);\r\n    };\r\n\r\n    /**\r\n     * This method will set the visibility of the shape stroke.\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param enableStroke Whether the shape stroke is visible.\r\n     * @returns\r\n     */\r\n    setEnableStroke = async (id: Id, enableStroke: boolean) => {\r\n        const properties: ShapeProperties = { enableStroke: enableStroke };\r\n        return this.setShapeProperties(id, properties);\r\n    };\r\n\r\n    /**\r\n     * This method will set the shape stroke color of a specified shape frame.\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param strokeColor the new shape stroke color that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setStrokeColor = async (id: Id, strokeColor: ColorUsage) => {\r\n        const properties: ShapeProperties = { strokeColor: strokeColor };\r\n        return this.setShapeProperties(id, properties);\r\n    };\r\n\r\n    /**\r\n     * This method will set the shape stroke weight of a specified shape frame.\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param strokeWeight the new shape stroke weight that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setStrokeWeight = async (id: Id, strokeWeight: number) => {\r\n        const properties: ShapeProperties = { strokeWeight: strokeWeight };\r\n        return this.setShapeProperties(id, properties);\r\n    };\r\n\r\n    /**\r\n     * This method will set the flag to change the way the rectangle shape corners will be changed: all at once or separately.\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param allCornersSame the new flag that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setFlagAllCornersSame = async (id: Id, allCornersSame: boolean) => {\r\n        const properties: ShapeProperties = { allCornersSame: allCornersSame };\r\n        return this.setShapeProperties(id, properties);\r\n    };\r\n\r\n    /**\r\n     * This method updates radii of the rectangle and polygon shapes\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param radius A radius object to update a desired corner;\r\n     * @returns\r\n     */\r\n    private setShapeCorners = async (id: Id, radius: CornerRadiusUpdateModel) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setShapeCorners(id, JSON.stringify(radius))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the radius for all corners of the rectangle and polygon shapes\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param radius A radius to update all corners at once;\r\n     * @returns\r\n     */\r\n    setRadiusAll = async (id: Id, radius: number) => {\r\n        const cornerRadius: CornerRadiusUpdateModel = { radiusAll: radius };\r\n        return this.setShapeCorners(id, cornerRadius);\r\n    };\r\n\r\n    /**\r\n     * This method will set the radius for the top left corner of the rectangle shape\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param radius A radius to update the top left corner;\r\n     * @returns\r\n     */\r\n    setRadiusTopLeft = async (id: Id, radius: number) => {\r\n        const cornerRadius: CornerRadiusUpdateModel = { topLeft: radius };\r\n        return this.setShapeCorners(id, cornerRadius);\r\n    };\r\n\r\n    /**\r\n     * This method will set the radius for the bottom left corner of the rectangle shape\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param radius A radius to update the bottom left corner;\r\n     * @returns\r\n     */\r\n    setRadiusBottomLeft = async (id: Id, radius: number) => {\r\n        const cornerRadius: CornerRadiusUpdateModel = { bottomLeft: radius };\r\n        return this.setShapeCorners(id, cornerRadius);\r\n    };\r\n\r\n    /**\r\n     * This method will set the radius for the top right corner of the rectangle shape\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param radius A radius to update the top right corner;\r\n     * @returns\r\n     */\r\n    setRadiusTopRight = async (id: Id, radius: number) => {\r\n        const cornerRadius: CornerRadiusUpdateModel = { topRight: radius };\r\n        return this.setShapeCorners(id, cornerRadius);\r\n    };\r\n\r\n    /**\r\n     * This method will set the radius for the bottom right corner of the rectangle shape\r\n     * @param id the id of the shapeFrame that needs to get updated.\r\n     * @param radius A radius to update the bottom right corner;\r\n     * @returns\r\n     */\r\n    setRadiusBottomRight = async (id: Id, radius: number) => {\r\n        const cornerRadius: CornerRadiusUpdateModel = { bottomRight: radius };\r\n        return this.setShapeCorners(id, cornerRadius);\r\n    };\r\n}\r\n","import type { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport {\r\n    BlendMode,\r\n    FitMode,\r\n    FrameLayoutType,\r\n    FrameType,\r\n    FrameTypeEnum,\r\n    ImageFrameConnectorSource,\r\n    ImageFrameSource,\r\n    ImageFrameUrlSource,\r\n    ImageSourceTypeEnum,\r\n    UpdateZIndexMethod,\r\n    VerticalAlign,\r\n} from '../types/FrameTypes';\r\nimport { ColorUsage } from '../types/ColorStyleTypes';\r\nimport { ShapeType } from '../types/ShapeTypes';\r\nimport { ShapeController } from './ShapeController';\r\n\r\n/**\r\n * The FrameController is responsible for all communication regarding Frames.\r\n * Methods inside this controller can be called by `window.SDK.frame.{method-name}`\r\n */\r\nexport class FrameController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n        this.shapeController = new ShapeController(this.#editorAPI);\r\n    }\r\n\r\n    /**\r\n     * This variable helps to redirect shapes related methods to newly introduced ShapeController\r\n     * to avoid any breaking changes\r\n     */\r\n    private shapeController: ShapeController;\r\n    /**\r\n     * This method returns the list of frames\r\n     * @returns list of all frames\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFrames().then((result) => getEditorResponseData<FrameType[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the list of selected frames\r\n     * @returns list of all selected frames\r\n     */\r\n    getSelected = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getSelectedFrames().then((result) => getEditorResponseData<FrameType[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the list of frames by id\r\n     * @param id the id of a specific page\r\n     * @returns list of all frames by id\r\n     */\r\n    getAllByPageId = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFramesByPageId(id).then((result) => getEditorResponseData<FrameType[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a frame by its name\r\n     * @param name the name of a specific frame\r\n     * @returns frame properties\r\n     */\r\n    getByName = async (name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFrameByName(name).then((result) => getEditorResponseData<FrameType>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a frame by its id\r\n     * @param id the id of a specific frame\r\n     * @returns frame properties\r\n     */\r\n    getById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFrameById(id).then((result) => getEditorResponseData<FrameType>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns all frame properties on current layout\r\n     * @returns all frame properties on current layout\r\n     */\r\n    getPropertiesOnSelectedLayout = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getFramePropertiesOnSelectedLayout()\r\n            .then((result) => getEditorResponseData<FrameLayoutType[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns frame layout properties for a given frame and layout\r\n     * @param id the id of a specific frame\r\n     * @param layoutId the id of a specific layout\r\n     * @returns frame layout properties\r\n     */\r\n    getLayoutProperties = async (id: Id, layoutId?: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getFramePropertiesByFrameId(id, layoutId)\r\n            .then((result) => getEditorResponseData<FrameLayoutType>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a list of frame properties for a given layout\r\n     * @param id the id of a specific layout\r\n     * @returns list of frame layout properties\r\n     */\r\n    getAllLayoutProperties = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getFramesProperties(id).then((result) => getEditorResponseData<FrameLayoutType[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the frame size (width and height) to the frame's original value\r\n     * @param id the id of a specific frame\r\n     * @returns\r\n     */\r\n    resetSize = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameSize(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will select a specific frame\r\n     * @param id the id of a specific frame\r\n     * @returns\r\n     */\r\n    select = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.selectFrames([id]).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will select multipleFrames\r\n     * @param ids An array of all ids you want to select\r\n     * @returns\r\n     */\r\n    selectMultiple = async (ids: Id[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.selectFrames(ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method changes the order of frames in the z-index list.\r\n     * @param order the index in the list to move to\r\n     * @param ids An array of all IDs you want to move to the given index\r\n     * @returns\r\n     */\r\n    reorderFrames = async (order: number, ids: Id[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.reorderFrames(order, ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will update the z-index of a frame.\r\n     * @param id the id of the frame you want to change the z-index of\r\n     * @param method the z-index update method to perform\r\n     * @returns\r\n     */\r\n    setZIndex = async (id: Id, method: UpdateZIndexMethod) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setFrameZIndex(id, method).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the height of a specific frame\r\n     * @param id the id of a specific frame\r\n     * @param height the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setHeight = async (id: Id, height: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameHeight(id, height)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the rotation angle of a specific frame\r\n     * @param id the id of a specific frame\r\n     * @param rotation the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setRotation = async (id: Id, rotation: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameRotation(id, rotation)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the width of a specific frame\r\n     * @param id the id of a specific frame\r\n     * @param width the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setWidth = async (id: Id, width: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameWidth(id, width)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the x value of a specific frame\r\n     * @param id the id of a specific frame\r\n     * @param XValue the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setX = async (id: Id, XValue: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameX(id, XValue)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the y value of a specific frame\r\n     * @param id the id of a specific frame\r\n     * @param YValue the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setY = async (id: Id, YValue: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameY(id, YValue)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will update the name of a specific frame\r\n     * @param id the id of a specific frame\r\n     * @param name the new name that the frame should receive\r\n     * @returns\r\n     */\r\n    rename = async (id: Id, name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.renameFrame(id, name).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset properties of a specific frame to their original values\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    reset = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrame(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n    /**\r\n     * This method will reset the x value of a specific frame to its original value\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    resetX = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameX(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the y value of a specific frame to its original value\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    resetY = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameY(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the rotation value of a specific frame to its original value\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    resetRotation = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameRotation(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the width of a specific frame to its original value\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    resetWidth = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameWidth(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the height of a specific frame to its original value\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    resetHeight = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetFrameHeight(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the fitMode property of a specific frame to its original value\r\n     * @param id the id of the frame that needs to get reset\r\n     * @returns\r\n     */\r\n    resetImageFrameFitMode = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetImageFrameFitMode(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * @deprecated Use `setIsVisible` instead.\r\n     * \r\n     * This method will set the visibility property of a specified frame. If set to false the frame will be invisible and vice versa.\r\n     * @param id the id of the frame that needs to get updated\r\n     * @param value True means the frame gets visible, false means the frame gets invisible\r\n     * @returns\r\n     */\r\n    setVisibility = async (id: Id, value: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setFrameIsVisible(id, value).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the isVisible property of a specified frame. If set to false the frame will be invisible and vice versa.\r\n     * @param id the id of the frame that needs to get updated\r\n     * @param value True means the frame gets visible, false means the frame gets invisible\r\n     * @returns\r\n     */\r\n    setIsVisible = async (id: Id, value: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setFrameIsVisible(id, value).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will remove a specific frame using the Id.\r\n     * @param id the id of the frame that needs to be deleted\r\n     * @returns\r\n     */\r\n    remove = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeFrame(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will create a new frame of 'type' to the template positioned on the requested\r\n     * coordinates.\r\n     * @param type the type of frame to create\r\n     * @param x X coordinate of the new frame within the template\r\n     * @param y Y coordinate of the new frame within the template\r\n     * @param width Width of the new frame within the template\r\n     * @param height Height of the new frame within the template\r\n     * @returns the newly created frame's id\r\n     */\r\n    create = async (type: FrameTypeEnum, x: number, y: number, width: number, height: number) => {\r\n        const res = await this.#editorAPI;\r\n        return res.addFrame(type, x, y, width, height).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will create a new frame of 'type' type to the template positioned on the requested\r\n     * coordinates.\r\n     * @param type the type of frame to create\r\n     * @param x X coordinate of the new frame within the template\r\n     * @param y Y coordinate of the new frame within the template\r\n     * @param width Width of the new frame within the template\r\n     * @param height Height of the new frame within the template\r\n     * @returns the newly created shape frame's id\r\n     */\r\n    createShapeFrame = async (type: ShapeType, x: number, y: number, width: number, height: number) => {\r\n        const res = await this.#editorAPI;\r\n        return res.addFrame(type, x, y, width, height).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets or removes the image source to the ImageFrame\r\n     * @param imageFrameId the id of the imageFrame where an image needs to be assigned to\r\n     * @param newImageSource A new image source\r\n     * @returns\r\n     */\r\n    private updateImageSource = async (imageFrameId: Id, src: ImageFrameSource | null) => {\r\n        const res = await this.#editorAPI;\r\n        const srcJson = src !== null ? JSON.stringify(src) : null;\r\n        return res.setImageSource(imageFrameId, srcJson).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes the image source from the ImageFrame\r\n     * @param imageFrameId the id of the imageFrame where an image needs to be removed from\r\n     */\r\n    removeImageSource = async (imageFrameId: string) => {\r\n        return this.updateImageSource(imageFrameId, null);\r\n    };\r\n\r\n    /**\r\n     * This method will assign an image from a mediaConnector to the correct ImageFrame\r\n     * @param id Unique Id of the media connector\r\n     * @param imageFrameId the id of the imageFrame where an image needs to be assigned to\r\n     * @param assetId Unique id of the asset that you want to assign to the imageFrame\r\n     * @returns\r\n     */\r\n    setImageFromConnector = async (imageFrameId: Id, connectorId: Id, assetId: Id) => {\r\n        const src: ImageFrameConnectorSource = {\r\n            id: connectorId,\r\n            assetId,\r\n            type: ImageSourceTypeEnum.connector,\r\n        };\r\n        return this.updateImageSource(imageFrameId, src);\r\n    };\r\n\r\n    /**\r\n     * This method will assign an image from url to the correct ImageFrame\r\n     * Make sure the url can be accessed by the editor.\r\n     * @param imageFrameId the id of the imageFrame where an image needs to be assigned to\r\n     * @param url A valid image uri\r\n     * @returns\r\n     */\r\n    setImageFromUrl = async (imageFrameId: Id, url: string) => {\r\n        const source: ImageFrameUrlSource = { url: url, type: ImageSourceTypeEnum.url };\r\n        return this.updateImageSource(imageFrameId, source);\r\n    };\r\n\r\n    /**\r\n     * This method will set the fitMode property of a specified image frame.\r\n     * @param imageFrameId the id of the imageFrame that needs to get updated.\r\n     * @param fitMode the new fitMode that you want to set to the imageFrame.\r\n     * @returns\r\n     */\r\n    setImageFrameFitMode = async (imageFrameId: Id, fitMode: FitMode) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setImageFrameFitMode(imageFrameId, fitMode).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n    /**\r\n     * This method will set the constrainProportions property of a specified frame.\r\n     * @param id the id of the frame that needs to get updated.\r\n     * @param constrainProportions The new constraint that you want to set to the frame.\r\n     * @returns\r\n     */\r\n    setFrameConstrainProportions = async (id: Id, constrainProportions: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setFrameConstrainProportions(id, constrainProportions)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the vertical alignment property of a specified frame.\r\n     * @param id the id of the frame that needs to get updated\r\n     * @param verticalAlign the new vertical alignment to be set to the frame.\r\n     * @returns\r\n     */\r\n    setVerticalAlign = async (id: Id, verticalAlign: VerticalAlign) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVerticalAlignment(id, verticalAlign).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the min copyFitting property of a specified frame.\r\n     * @param id the id of the frame that needs to get updated\r\n     * @param value the new min copyFitting value to be set to the frame.\r\n     * @returns\r\n     */\r\n    setMinCopyfitting = async (id: Id, value: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setMinCopyfitting(id, value)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the max copyFitting property of a specified frame.\r\n     * @param id the id of the frame that needs to get updated\r\n     * @param value the new max copyFitting value to be set to the frame.\r\n     * @returns\r\n     */\r\n    setMaxCopyfitting = async (id: Id, value: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setMaxCopyfitting(id, value)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will enable copyFitting on a specified frame.\r\n     * @param id the id of the frame that needs to get updated\r\n     * @param value the new value to be set to the frame.\r\n     * @returns\r\n     */\r\n    setEnableCopyfitting = async (id: Id, value: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setEnableCopyfitting(id, value).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the frame minCopyfitting to the frame's original value\r\n     * @param id the id of a specific frame\r\n     * @returns\r\n     */\r\n    resetMinCopyfitting = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetMinCopyfitting(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the frame maxCopyfitting to the frame's original value\r\n     * @param id the id of a specific frame\r\n     * @returns\r\n     */\r\n    resetMaxCopyfitting = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetMaxCopyfitting(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the frame enableCopyfitting to the frame's original value\r\n     * @param id the id of a specific frame\r\n     * @returns\r\n     */\r\n    resetEnableCopyfitting = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetEnableCopyfitting(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the visibility of the shape fill.\r\n     * @param shapeFrameId the id of the shapeFrame that needs to get updated.\r\n     * @param enableFill Whether the shape fill is visible.\r\n     * @returns\r\n     */\r\n    setShapeFrameEnableFill = async (shapeFrameId: Id, enableFill: boolean) => {\r\n        return this.shapeController.setEnableFill(shapeFrameId, enableFill);\r\n    };\r\n\r\n    /**\r\n     * This method will set the shape fill color of a specified shape frame.\r\n     * @param shapeFrameId the id of the shapeFrame that needs to get updated.\r\n     * @param fillColor the new shape fill color that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setShapeFrameFillColor = async (shapeFrameId: Id, fillColor: ColorUsage) => {\r\n        return this.shapeController.setFillColor(shapeFrameId, fillColor);\r\n    };\r\n\r\n    /**\r\n     * This method will set the visibility of the shape stroke.\r\n     * @param shapeFrameId the id of the shapeFrame that needs to get updated.\r\n     * @param enableStroke Whether the shape stroke is visible.\r\n     * @returns\r\n     */\r\n    setShapeFrameEnableStroke = async (shapeFrameId: Id, enableStroke: boolean) => {\r\n        return this.shapeController.setEnableStroke(shapeFrameId, enableStroke);\r\n    };\r\n\r\n    /**\r\n     * This method will set the shape stroke color of a specified shape frame.\r\n     * @param shapeFrameId the id of the shapeFrame that needs to get updated.\r\n     * @param strokeColor the new shape stroke color that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setShapeFrameStrokeColor = async (shapeFrameId: Id, strokeColor: ColorUsage) => {\r\n        return this.shapeController.setStrokeColor(shapeFrameId, strokeColor);\r\n    };\r\n\r\n    /**\r\n     * This method will set the shape stroke weight of a specified shape frame.\r\n     * @param shapeFrameId the id of the shapeFrame that needs to get updated.\r\n     * @param strokeWeight the new shape stroke weight that you want to set to the shapeFrame.\r\n     * @returns\r\n     */\r\n    setShapeFrameStrokeWeight = async (shapeFrameId: Id, strokeWeight: number) => {\r\n        return this.shapeController.setStrokeWeight(shapeFrameId, strokeWeight);\r\n    };\r\n\r\n    /**\r\n     * This method will set the blend mode of a specified shape frame\r\n     * @param id the id of a specific frame\r\n     * @param blendMode the blend mode\r\n     * @returns\r\n     */\r\n    setBlendMode = async (id: Id, blendMode: BlendMode) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setFrameBlendMode(id, blendMode).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will make the specified image frame go into cropping mode.\r\n     * @param id the id of a specific image frame\r\n     * @returns\r\n     */\r\n    enterCropMode = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.enterCropMode(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will exit cropping mode while saving the applied crop.\r\n     * @returns\r\n     */\r\n    applyCropMode = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.applyCropMode().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the currently applied crop mode and apply the last selected fit mode again.\r\n     * @param id the id of a specific image frame\r\n     * @returns\r\n     */\r\n    resetCropMode = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetCropMode(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will exit cropping mode without saving the applied crop.\r\n     * @returns\r\n     */\r\n    exitCropMode = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.cancelCropMode().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import type { EditorAPI, EditorRawAPI, EditorResponse, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { Layout } from '../types/LayoutTypes';\r\nimport { CallSender } from 'penpal';\r\n\r\n/**\r\n * The LayoutController is responsible for all communication regarding Layouts.\r\n * Methods inside this controller can be called by `window.SDK.layout.{method-name}`\r\n */\r\nexport class LayoutController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n    #blobAPI: EditorRawAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n        this.#blobAPI = editorAPI as CallSender as EditorRawAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of layouts\r\n     * @returns list of all layouts\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getLayouts().then((result) => getEditorResponseData<Layout[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a layout by its id\r\n     * @param id the id of a specific layout\r\n     * @returns layout properties\r\n     */\r\n    getById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getLayoutById(id).then((result) => getEditorResponseData<Layout>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a layout by its name\r\n     * @param name the name of a specific layout\r\n     * @returns layout properties\r\n     */\r\n    getByName = async (name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getLayoutByName(name).then((result) => getEditorResponseData<Layout>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns the selected layout\r\n     * @returns layout properties\r\n     */\r\n    getSelected = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getSelectedLayout().then((result) => getEditorResponseData<Layout>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will remove a specific layout\r\n     * @param id the id of a specific layout\r\n     * @returns\r\n     */\r\n    remove = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeLayout(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will create a new child layout (a new layout is always child of a root / parent)\r\n     * @param parentId the id of a specific layout, being the parent\r\n     * @returns id of new layout\r\n     */\r\n    create = async (parentId: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.addLayout(parentId).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will update the name of a specific layout\r\n     * @param id the id of a specific layout\r\n     * @param name the new name that the layout should receive\r\n     * @returns\r\n     */\r\n    rename = async (id: Id, name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.renameLayout(id, name).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will select a specific layout\r\n     * @param id the id of a specific layout\r\n     * @returns\r\n     */\r\n    select = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.selectLayout(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will duplicate a specific layout\r\n     * @param id the id of a specific layout\r\n     * @returns id of specific layout\r\n     */\r\n    duplicate = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.duplicateLayout(id).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset a specific layout to its original value\r\n     * @param id the id of a specific layout\r\n     * @returns\r\n     */\r\n    reset = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetLayout(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the height of the layout to a specific value\r\n     * @param id the id of a specific layout\r\n     * @param height the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setHeight = async (id: Id, height: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setLayoutHeight(id, height)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the width of the layout to a specific value\r\n     * @param id the id of a specific layout\r\n     * @param width the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setWidth = async (id: Id, width: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setLayoutWidth(id, width)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the height of a specific layout to its original value\r\n     * @param id the id of a specific layout\r\n     * @returns\r\n     */\r\n    resetHeight = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetLayoutHeight(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will reset the width of a specific layout to its original value\r\n     * @param id the id of a specific layout\r\n     * @returns\r\n     */\r\n    resetWidth = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.resetLayoutWidth(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a UInt8Array containing a PNG encoded image of the currently selected layout.\r\n     * @returns UInt8Array snapshot of the current layout\r\n     */\r\n    getSelectedSnapshot = async () => {\r\n        const res = await this.#blobAPI;\r\n        return res.getPageSnapshot().then((result) => (result as Uint8Array) ?? (result as EditorResponse<null>));\r\n    };\r\n}\r\n","import { ConnectorConfigOptions, EditorAPI, EditorRawAPI, EditorResponse, Id, MetaData } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport {\r\n    DeprecatedMediaType,\r\n    ConnectorCapabilities,\r\n    MediaType,\r\n    QueryOptions,\r\n    QueryPage,\r\n} from '../types/ConnectorTypes';\r\nimport { CallSender } from 'penpal';\r\nimport { Media, MediaDownloadType } from '../types/MediaConnectorTypes';\r\n\r\n/**\r\n * The MediaConnectorController is responsible for all communication regarding media connectors.\r\n * Methods inside this controller can be called by `window.SDK.mediaConnector.{method-name}`\r\n *\r\n * The way CHILI Studio handles different sources of media is called 'MediaConnectors'. A MediaConnectors is an\r\n * implementation of a set of capabilities we need to interact with a certain Digital Asset Management system.\r\n * In essence a connector is the combination of a Javascript snippet and some metadata. The Javascript snippet\r\n * is loaded in the studio engine using a sandboxed Javascript execution engine (QuickJs). This allows us to\r\n * execute the media connector both on web using webassembly and on the server side during e.g. animation output\r\n * generation.\r\n * This controller is an interface to the running connector instance inside the studio engine.\r\n */\r\nexport class MediaConnectorController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n    #blobAPI: EditorRawAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n        this.#blobAPI = editorAPI as CallSender as EditorRawAPI;\r\n    }\r\n\r\n    /**\r\n     * Query a specific MediaConnector for data using both standardized queryOptions and the dynamic\r\n     * context as parameters. This call returns an array of Media items.\r\n     * @param id unique id of the media connector\r\n     * @param queryOptions stringified instance of `QueryOptions`\r\n     * @param context context that will be available in the connector script.\r\n     * @returns array of Media items\r\n     */\r\n    query = async (id: Id, queryOptions: QueryOptions, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorQuery(id, JSON.stringify(queryOptions), JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<QueryPage<Media>>(result));\r\n    };\r\n\r\n    /**\r\n     * Returns a single media using a specific MediaConnector.\r\n     *\r\n     * The connector needs to list `detail` as a supported capability.\r\n     * @param id unique id of the Media connector\r\n     * @param mediaId unique id of the Media\r\n     * @param context context that will be available in the connector script.\r\n     * @returns Media item\r\n     */\r\n    detail = async (id: Id, mediaId: string, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorDetail(id, mediaId, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<Media>(result));\r\n    };\r\n\r\n    /**\r\n     * The combination of a `connectorId` and `mediaId` is typically enough for a media connector to\r\n     * perform the download of this asset. The `download` endpoint is capable of relaying this information to the\r\n     * media connector instance running in the editor engine.\r\n     * @param id unique id of the media connector\r\n     * @param mediaId unique id of the media to download\r\n     * @param downloadType hint to the media connector about desired quality of the downloaded media\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    download = async (\r\n        id: Id,\r\n        mediaId: Id,\r\n        downloadType: MediaDownloadType,\r\n        context: MetaData = {},\r\n    ): Promise<Uint8Array> => {\r\n        const res = await this.#blobAPI;\r\n        return res\r\n            .mediaConnectorDownload(id, mediaId, downloadType, JSON.stringify(context))\r\n            .then((result) => (result as Uint8Array) ?? (result as EditorResponse<null>));\r\n    };\r\n\r\n    /**\r\n     * Depending on the connector capabilities, this api method allows you to upload new media to the\r\n     * connector's backend.\r\n     * @param id unique id of the media connector\r\n     * @param mediaId unique id of the media to upload\r\n     * @param blob byte array representation of the media to upload\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    upload = async (id: Id, mediaId: Id, blob: Uint8Array, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorUpload(id, mediaId, blob, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Depending on the connector capabilities, removes media identified by `mediaId` from the connector's backend storage\r\n     * @param id unique id of the media connector\r\n     * @param mediaId unique id of the media to download\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    remove = async (id: Id, mediaId: Id, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorRemove(id, mediaId, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Depending on the connector capabilities, copies media identified by `mediaId` to a new media item on the\r\n     * connector's backend\r\n     * @param id unique id of the media connector\r\n     * @param mediaId unique id of the media to download\r\n     * @param newName name of the copied media on the connector's backend\r\n     * @param context context that will be available in the connector script.\r\n     * @returns\r\n     */\r\n    copy = async (id: Id, mediaId: Id, newName: string, context: MetaData = {}) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorCopy(id, mediaId, newName, JSON.stringify(context))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * All connectors have a certain set of mappings they allow to be passed into the connector methods their context. This\r\n     * method allows you to discover which mappings are available for a given connector. If you want to use any of these\r\n     * mappings, they will be available in the `context` parameter of any connector method.\r\n     * @param id unique id of the media connector\r\n     * @returns connector mappings\r\n     */\r\n    getConfigurationOptions = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorGetConfigurationOptions(id)\r\n            .then((result) => getEditorResponseData<ConnectorConfigOptions>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns what capabilities the selected connector has. It gives an indication what methods can\r\n     * be used successfully for a certain connector.\r\n     * @param id unique id of the media connector\r\n     * @returns connector capabilities\r\n     */\r\n    getCapabilities = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .mediaConnectorGetCapabilities(id)\r\n            .then((result) => getEditorResponseData<ConnectorCapabilities>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will parse the deprecatedMediaType to the new media type. This method will be removed once the deprecatedMediaType is out of use\r\n     * @param deprecatedType is 0 or 1\r\n     * @returns connector capabilities\r\n     */\r\n    parseDeprecatedMediaType = (deprecatedType: DeprecatedMediaType) => {\r\n        if (deprecatedType === DeprecatedMediaType.file) return MediaType.file;\r\n        if (deprecatedType === DeprecatedMediaType.collection) return MediaType.collection;\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { Page } from '../types/PageTypes';\r\n\r\n/**\r\n * The PageController is responsible for all communication regarding Pages.\r\n * Methods inside this controller can be called by `window.SDK.page.{method-name}`\r\n */\r\nexport class PageController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of pages\r\n     * @returns list of all pages\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getPages().then((result) => getEditorResponseData<Page[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a page by its id\r\n     * @param id the id of a specific page\r\n     * @returns page properties\r\n     */\r\n    getById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getPageById(id).then((result) => getEditorResponseData<Page>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the width of the page to a specific value.\r\n     * This only works if the document is a project.\r\n     * @param id the id of a specific page\r\n     * @param width the string value that will be calculated (f.e. 1+1 will result in 2) The notation is in pixels\r\n     * @returns\r\n     */\r\n    setWidth = async (id: Id, width: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setPageWidth(id, width)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method will set the height of the page to a specific value.\r\n     * This only works if the document is a project.\r\n     * @param id the id of a specific page\r\n     * @param height the string value that will be calculated (f.e. 1+1 will result in 2). The notation is in pixels\r\n     * @returns\r\n     */\r\n    setHeight = async (id: Id, height: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .setPageHeight(id, height)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { ParagraphStyle, ParagraphStyleUpdate } from '../types/ParagraphStyleTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The ParagraphStyleController is responsible for all communication regarding paragraph styles.\r\n * Methods inside this controller can be called by `window.SDK.paragraphStyle.{method-name}`\r\n */\r\nexport class ParagraphStyleController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of paragraph styles\r\n     * @returns\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getParagraphStyles().then((result) => getEditorResponseData<ParagraphStyle[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a paragraph style by id\r\n     * @param id the id of a specific paragraph style\r\n     * @returns\r\n     */\r\n    getById = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .getParagraphStyleById(id)\r\n            .then((result) => getEditorResponseData<ParagraphStyle>(result));\r\n    };\r\n\r\n    /**\r\n     * This method creates a new paragraph style\r\n     * @returns the id of new paragraph style\r\n     */\r\n    create = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.createParagraphStyle().then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method duplicates a paragraph style\r\n     * @param id the id of a specific paragraph style\r\n     * @returns the new paragraph style id\r\n     */\r\n    duplicate = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.duplicateParagraphStyle(id).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method updates a paragraph style\r\n     * @param id the id of a specific paragraph style\r\n     * @param properties The new paragraph style properties\r\n     * @returns\r\n     */\r\n    update = async (id: Id, properties: ParagraphStyleUpdate) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .updateParagraphStyle(id, JSON.stringify(properties))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method renames a paragraph style\r\n     * @param id the id of a specific paragraph style\r\n     * @param name the new name of the paragraph style\r\n     * @returns\r\n     */\r\n    rename = async (id: Id, name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.renameParagraphStyle(id, name).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a paragraph style\r\n     * @param id the id of a specific paragraph style\r\n     * @returns\r\n     */\r\n    remove = async (id: Id) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeParagraphStyle(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method changes positions of paragraph styles\r\n     * @param order the position of the paragraph styles\r\n     * @param ids the list of paragraph styles ids\r\n     * @returns\r\n     */\r\n    move = async (order: number, ids: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.moveParagraphStyles(order, ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n}\r\n","import { ConfigType, Id } from '../types/CommonTypes';\r\nimport { ToolType } from '../utils/enums';\r\n\r\n/**\r\n * The SubscriberController is responsible for all listeners which can influence the application-state from outside.\r\n * Callbacks inside this controller can be set by `window.SDK.subscriber.{method-name}`\r\n */\r\nexport class SubscriberController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    private config: ConfigType;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(config: ConfigType) {\r\n        this.config = config;\r\n    }\r\n\r\n    /**\r\n     * Listener on actions, if this changes, this listener will get triggered with the updates\r\n     * @param actions Stringified array of DocumentAction type\r\n     */\r\n    onActionsChanged = (actions: string) => {\r\n        const callBack = this.config.onActionsChanged;\r\n        callBack && callBack(JSON.parse(actions));\r\n    };\r\n\r\n    /**\r\n     * Listener on when a certain animation gets changed\r\n     * @param animation Stringified array of FrameAnimationType\r\n     */\r\n    onAnimationChanged = (animation: string) => {\r\n        const callBack = this.config.onFrameAnimationsChanged;\r\n        callBack && callBack(JSON.parse(animation));\r\n    };\r\n\r\n    /**\r\n     * Listener on the playback state of the animation, it contains the current time of the playback (in milliseconds) and a flag that describes if the animation is currently playing\r\n     * @param animationPlaybackState Stringified array of AnimationPlaybackType\r\n     */\r\n    onAnimationPlaybackChanged = (animationPlaybackState: string) => {\r\n        const callBack = this.config.onScrubberPositionChanged;\r\n        callBack && callBack(JSON.parse(animationPlaybackState));\r\n    };\r\n\r\n    /**\r\n     * Listener on the state of the currently selected layout, if its properties are changed, this listener will get triggered with the new properties\r\n     * @param layoutProperties Stringified object of LayoutPropertiesType\r\n     */\r\n    onSelectedLayoutPropertiesChanged = (layoutProperties: string) => {\r\n        const callBack = this.config.onSelectedLayoutPropertiesChanged;\r\n        callBack && callBack(JSON.parse(layoutProperties));\r\n    };\r\n\r\n    /**\r\n     * Listener on the state of the currently selected frame, if this changes, this listener will get triggered with the updates\r\n     * @param frameLayout Stringified object of FrameLayoutType\r\n     */\r\n    onSelectedFrameLayoutChanged = (frameLayout: string) => {\r\n        const callBack = this.config.onSelectedFrameLayoutChanged;\r\n        callBack && callBack(JSON.parse(frameLayout));\r\n    };\r\n\r\n    /**\r\n     * Listener on the state of the currently selected frame, it contains some basic information on the type of frame it is\r\n     * @param frameContent Stringified object of FrameType\r\n     */\r\n    onSelectedFrameContentChanged = (frameContent: string) => {\r\n        const callBack = this.config.onSelectedFrameContentChanged;\r\n        callBack && callBack(JSON.parse(frameContent));\r\n    };\r\n\r\n    /**\r\n     * A listener on the general state of the document, gets triggered every time a change is done on the document.\r\n     */\r\n    onStateChanged = () => {\r\n        const callBack = this.config.onStateChanged;\r\n        callBack && callBack();\r\n    };\r\n\r\n    /**\r\n     * A listener on when the document is fully loaded.\r\n     */\r\n    onDocumentLoaded = () => {\r\n        const callBack = this.config.onDocumentLoaded;\r\n        callBack && callBack();\r\n    };\r\n\r\n    /**\r\n     * To be implemented, gets triggered when clicking on the pageTitle on the canvas.\r\n     */\r\n    onPageSelectionChanged = () => {\r\n        const callBack = this.config.onPageSelectionChanged;\r\n        callBack && callBack();\r\n    };\r\n\r\n    /**\r\n     * Listener on when variables change\r\n     * @param variablesJson Stringified array of Variable\r\n     */\r\n    onVariableListChanged = (variablesJson: string) => {\r\n        const callBack = this.config.onVariableListChanged;\r\n        callBack && callBack(JSON.parse(variablesJson));\r\n    };\r\n\r\n    /**\r\n     * Listener on when the tool has changed by the canvas\r\n     * @param tool the string representation of a certain tool\r\n     */\r\n    onSelectedToolChanged = (tool: string) => {\r\n        const callBack = this.config.onSelectedToolChanged;\r\n        callBack && callBack(tool as ToolType);\r\n    };\r\n\r\n    /**\r\n     * Listener on state changes\r\n     * @param undoState Stringified object of UndoState\r\n     */\r\n    onUndoStateChanged = (undoState: string) => {\r\n        const callBack = this.config.onUndoStackStateChanged;\r\n        callBack && callBack(JSON.parse(undoState));\r\n    };\r\n\r\n    /**\r\n     * Listener on the state of the currently selected layout's frames, if this changes, this listener will get triggered with the updates\r\n     * @param layoutFrames Stringified object of Frames\r\n     */\r\n    onSelectedLayoutFramesChanged = (layoutFrames: string) => {\r\n        const callBack = this.config.onSelectedLayoutFramesChanged;\r\n        callBack && callBack(JSON.parse(layoutFrames));\r\n    };\r\n\r\n    /**\r\n     * Listener on the state of the currently selected text's styles, if this changes, this listener will get triggered with the updates\r\n     * @param styles Stringified object of styles\r\n     */\r\n    onSelectedTextStyleChanged = (styles: string) => {\r\n        const callBack = this.config.onSelectedTextStyleChanged;\r\n        callBack && callBack(JSON.parse(styles));\r\n    };\r\n\r\n    /**\r\n     * Listener on the state of the currently selected color's styles, if this changes, this listener will get triggered with the updates\r\n     * @param colors Stringified object of colors\r\n     */\r\n    onColorsChanged = (colors: string) => {\r\n        const callBack = this.config.onColorsChanged;\r\n        callBack && callBack(JSON.parse(colors));\r\n    };\r\n\r\n    /**\r\n     * Listener on paragraph styles, if this changes, this listener will get triggered with the updates\r\n     * @param paragraphStyles Stringified object of paragraph styles\r\n     */\r\n    onParagraphStylesChanged = (paragraphStyles: string) => {\r\n        const callBack = this.config.onParagraphStylesChanged;\r\n        callBack && callBack(JSON.parse(paragraphStyles));\r\n    };\r\n\r\n    /**\r\n     * Listener on character styles, if this changes, this listener will get triggered with the updates\r\n     * @param characterStyles Stringified object of character styles\r\n     */\r\n    onCharacterStylesChanged = (characterStyles: string) => {\r\n        const callBack = this.config.onCharacterStylesChanged;\r\n        callBack && callBack(JSON.parse(characterStyles));\r\n    };\r\n\r\n    /**\r\n     * Listener on fonts, if this changes, this listener will get triggered with the updates\r\n     * @param fonts Stringified object of font families\r\n     */\r\n    onFontFamiliesChanged = (fonts: string) => {\r\n        const callBack = this.config.onFontFamiliesChanged;\r\n        callBack && callBack(JSON.parse(fonts));\r\n    };\r\n\r\n    /**\r\n     * Listener on selected layout id, this listener will get triggered when a different layout is selected.\r\n     * @param id the currently selected layout id\r\n     */\r\n    onSelectedLayoutIdChanged = (id: Id) => {\r\n        const callBack = this.config.onSelectedLayoutIdChanged;\r\n        callBack && callBack(id);\r\n    };\r\n\r\n    /**\r\n     * Listener on layouts, this listener will get triggered when a (sub)layout is\r\n     * - created\r\n     * - removed\r\n     * - renamed\r\n     * - duplicated\r\n     * @param layouts Stringified object of layouts\r\n     */\r\n    onLayoutsChanged = (layouts: string) => {\r\n        const callBack = this.config.onLayoutsChanged;\r\n        callBack && callBack(JSON.parse(layouts));\r\n    };\r\n\r\n    /**\r\n     * Listener on scale factor of the canvas, this listener will get triggered when a zoom is applied to the canvas\r\n     * @param zoom Stringified scale factor\r\n     */\r\n    onZoomChanged = (zoom: string) => {\r\n        const callBack = this.config.onZoomChanged;\r\n        callBack && callBack(JSON.parse(zoom));\r\n    };\r\n\r\n    /**\r\n     * Listener on connector events, this listener will get triggered when a connector emits one of those events\r\n     * - reloadRequired\r\n     * - authChanged\r\n     * - unloaded\r\n     * - stateChanged\r\n     *\r\n     * stateChanged - this event will be triggered by connector states: loading, loaded, running, ready, error\r\n     * @param connectorEvent Stringified object of ConnectorEvent\r\n     */\r\n    onConnectorEvent = (connectorEvent: string) => {\r\n        const callBack = this.config.onConnectorEvent;\r\n        callBack && callBack(JSON.parse(connectorEvent));\r\n    };\r\n\r\n    /**\r\n     * Listener on page size, this listener will get triggered when the page size is changed, while the document is a `project`.\r\n     * This will not emit anything if your document is a `template`.\r\n     * @param pageSize Stringified object of the PageSize\r\n     */\r\n    onPageSizeChanged = (pageSize: string) => {\r\n        const callBack = this.config.onPageSizeChanged;\r\n        callBack && callBack(JSON.parse(pageSize));\r\n    };\r\n\r\n    /**\r\n     * Listener on corner radii of rectangle and polygon shapes, this listener will get triggered when any corner radius is changed\r\n     * @param cornerRadius Stringified object of the CornerRadius\r\n     */\r\n    onShapeCornerRadiusChanged = (cornerRadius: string) => {\r\n        const callBack = this.config.onShapeCornerRadiusChanged;\r\n        callBack && callBack(JSON.parse(cornerRadius));\r\n    };\r\n\r\n    /**\r\n     * Listener of editor entering / exiting the crop mode\r\n     * @param id frame id when entering / null when exiting\r\n     */\r\n    onCropActiveFrameIdChanged = (id?: Id) => {\r\n        const callBack = this.config.onCropActiveFrameIdChanged;\r\n        callBack && callBack(id);\r\n    };\r\n\r\n    /**\r\n     * Listener on async errors.\r\n     * Async errors are thrown at times not directly tied to SDK calls.\r\n     * e.g. Getting an action error triggered after a late event.\r\n     *\r\n     * If this is an `ActionAsyncError`:\r\n     * - `id` refers to the action id\r\n     * - `event` refers to the event that triggered the action\r\n     * - `eventChain` refers the chain of events that lead to the action, first\r\n     * item being the closest parent.\r\n     * @param asyncError error triggered asynchronously\r\n     */\r\n    onAsyncError = (asyncError: string) => {\r\n        const callBack = this.config.onAsyncError;\r\n        callBack && callBack(JSON.parse(asyncError));\r\n    };\r\n}\r\n","export enum FramePropertyNames {\r\n    FRAME_X = 'frameX',\r\n    FRAME_Y = 'frameY',\r\n    WIDTH = 'width',\r\n    HEIGHT = 'height',\r\n    FRAME_ROTATION = 'frameRotation',\r\n}\r\nexport enum LayoutPropertyNames {\r\n    LAYOUT_HEIGHT = 'layoutHeight',\r\n    LAYOUT_WIDTH = 'layoutWidth',\r\n}\r\n\r\nexport enum ToolType {\r\n    SELECT = 'select',\r\n    ZOOM = 'zoom',\r\n    HAND = 'hand',\r\n    IMAGE_FRAME = 'imageFrame',\r\n    TEXT_FRAME = 'textFrame',\r\n    SHAPE_RECT = 'rect',\r\n    SHAPE_ELLIPSE = 'ellipse',\r\n    SHAPE_POLYGON = 'polygon',\r\n}\r\nexport enum DownloadFormats {\r\n    MP4 = 'mp4',\r\n    GIF = 'gif',\r\n    PNG = 'png',\r\n    JPG = 'jpg',\r\n    EXPERIMENTAL_PDF = 'pdf',\r\n}\r\n\r\nexport enum EnvironmentType {\r\n    SANDBOX = 'sandbox',\r\n    PRODUCTION = 'online',\r\n}\r\n","import { EditorAPI } from '../types/CommonTypes';\r\nimport { SelectedTextStyle, TextStyleUpdateType } from '../types/TextStyleTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The TextStyleController is responsible for all communication regarding text styles.\r\n * Methods inside this controller can be called by `window.SDK.textStyle.{method-name}`\r\n */\r\nexport class TextStyleController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    readonly #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method updates a selected Text's style properties\r\n     * @returns\r\n     */\r\n    set = async (style: TextStyleUpdateType) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .selectedTextStyleDeltaUpdate(JSON.stringify(style))\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a selected Text's style properties\r\n     * If the text is selected, then the inline style properties will be removed\r\n     * If the text is not selected and user tried to change any style property, the temporary style will be removed\r\n     * if there is no text selection and there is no temporary style, the inline paragraph properties will be removed\r\n     * @returns\r\n     */\r\n    removeSelected = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.selectedTextStyleClean().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method gets a selected Text's style properties\r\n     * @returns\r\n     */\r\n    getSelected = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getSelectedTextStyle().then((result) => getEditorResponseData<SelectedTextStyle>(result));\r\n    };\r\n}\r\n","import { EditorAPI } from '../types/CommonTypes';\r\nimport { ToolType } from '../utils/enums';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The ToolController is responsible for all communication regarding the tools.\r\n * Methods inside this controller can be called by `window.SDK.tool.{method-name}`\r\n */\r\nexport class ToolController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method sets the currently used tool\r\n     * @param tool\r\n     */\r\n    setTool = async (tool: ToolType) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setTool(tool).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns selected tool\r\n     */\r\n    getSelected = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getSelectedTool().then((result) => getEditorResponseData<ToolType>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a Pointer tool\r\n     */\r\n    setPointer = async () => {\r\n        return this.setTool(ToolType.SELECT);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a Move tool\r\n     */\r\n    setHand = async () => {\r\n        return this.setTool(ToolType.HAND);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a Zoom tool\r\n     */\r\n    setZoom = async () => {\r\n        await this.setTool(ToolType.ZOOM);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a TextFrame tool\r\n     */\r\n    setTextFrame = async () => {\r\n        return this.setTool(ToolType.TEXT_FRAME);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a ImageFrame tool\r\n     */\r\n    setImageFrame = async () => {\r\n        return this.setTool(ToolType.IMAGE_FRAME);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a ShapeRectangle tool\r\n     */\r\n    setShapeRect = async () => {\r\n        return this.setTool(ToolType.SHAPE_RECT);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a ShapeEllipse tool\r\n     */\r\n    setShapeEllipse = async () => {\r\n        return this.setTool(ToolType.SHAPE_ELLIPSE);\r\n    };\r\n\r\n    /**\r\n     * This method sets the used tool to a ShapePolygon tool\r\n     */\r\n    setShapePolygon = async () => {\r\n        return this.setTool(ToolType.SHAPE_POLYGON);\r\n    };\r\n}\r\n","import SDK from '..';\r\nimport { EditorAPI } from '../types/CommonTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The UndoManagerController is responsible for all communication regarding the Undo-Manager.\r\n * Methods inside this controller can be called by `window.SDK.undoManager.{method-name}`\r\n */\r\nexport class UndoManagerController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n    #advanced: AdvancedUndoManagerController;\r\n    #sdk: SDK;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(children: EditorAPI, sdk: SDK) {\r\n        this.#editorAPI = children;\r\n        this.#sdk = sdk;\r\n        this.#advanced = new AdvancedUndoManagerController(children);\r\n    }\r\n\r\n    /**\r\n     * This method undoes the last operation\r\n     * @returns\r\n     */\r\n    undo = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.undo().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method redoes the last operation\r\n     * @returns\r\n     */\r\n    redo = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.redo().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * Record any operations in the current scope. This will automatically begin\r\n     * the undo operation. Once you leave the record scope, it will end the undo operation. \r\n     * Even if you throw an exception inside the record scope it will still end it properly. \r\n     * @returns\r\n     */\r\n    record = async (operationName: string, undoOperationCallback: (sdk: SDK) => void) => {\r\n        try {\r\n            await this.#advanced.begin(operationName);\r\n\r\n            await undoOperationCallback(this.#sdk);\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n        finally {\r\n            await this.#advanced.end();\r\n        }\r\n    };\r\n}\r\n\r\nexport class AdvancedUndoManagerController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(children: EditorAPI) {\r\n        this.#editorAPI = children;\r\n    }\r\n\r\n    /**\r\n     * This will start a new undo operation. \r\n     * This will throw an exception when there is already an undo operation recording.\r\n     * @returns\r\n     */\r\n    begin = async (operationName: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.begin(operationName).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This will start a new undo operation if there is no other undo operation recording. \r\n     * This does not throw. \r\n     * @returns\r\n     */\r\n    beginIfNoneActive = async (operationName: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.beginIfNoneActive(operationName).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n\r\n    /**\r\n     * Ends the currently active recording operation. \r\n     * If there is no recording operation currently running this will throw an exception. \r\n     * @returns\r\n     */\r\n    end = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.end().then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n}\r\n\r\n","export const round = (val: number, precision = 2) => {\r\n    const hundred = Math.pow(10, precision);\r\n    return Math.round(val * hundred) / hundred;\r\n};","import { round } from '../utils/MathUtils';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\nimport { EnvironmentType } from '../utils/enums';\r\n\r\n/**\r\n * The UtilsController exposes a set of useful utilities that can be used to make some repeated tasks a bit easier\r\n * Methods inside this controller can be called by `window.SDK.utils.{method-name}`\r\n */\r\nexport class UtilsController {\r\n\r\n    /**\r\n     * This method can round a value to a certain precision, default is 2\r\n     * @param val the value that needs to be rounded\r\n     * @param precision the precision of the rounding operation\r\n     * @returns the rounded value as a number\r\n     */\r\n    round = (val: number, precision?: number) =>\r\n        getEditorResponseData<number>({\r\n            data: String(round(val, precision)),\r\n            success: true,\r\n            status: 200,\r\n            parsedData: null,\r\n        });\r\n\r\n    createEnvironmentBaseURL = (parameters: { type?: EnvironmentType; environment?: string; version?: string }) => {\r\n        const { type = EnvironmentType.SANDBOX, environment = 'ft-nostress', version = '1' } = parameters;\r\n        const host = type == EnvironmentType.SANDBOX ? 'chili-publish-sandbox' : 'chili-publish';\r\n        return `https://${environment}.${host}.online/grafx/api/v${version}/environment/${environment}`;\r\n    };\r\n}\r\n","import { EditorAPI, Id } from '../types/CommonTypes';\r\nimport { ConnectorRegistration } from '../types/ConnectorTypes';\r\nimport {\r\n    Variable,\r\n    VariableType,\r\n} from '../types/VariableTypes';\r\nimport { getEditorResponseData } from '../utils/EditorResponseData';\r\n\r\n/**\r\n * The VariableController is responsible for all communication regarding the variables.\r\n * Methods inside this controller can be called by `window.SDK.variable.{method-name}`\r\n */\r\nexport class VariableController {\r\n    /**\r\n     * @ignore\r\n     */\r\n    #editorAPI: EditorAPI;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    constructor(editorAPI: EditorAPI) {\r\n        this.#editorAPI = editorAPI;\r\n    }\r\n\r\n    /**\r\n     * This method returns the list of variables\r\n     * @returns\r\n     */\r\n    getAll = async () => {\r\n        const res = await this.#editorAPI;\r\n        return res.getVariables().then((result) => getEditorResponseData<Variable[]>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a variable by id\r\n     * @param id the id of a specific variable\r\n     * @returns\r\n     */\r\n    getById = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getVariableById(id).then((result) => getEditorResponseData<Variable>(result));\r\n    };\r\n\r\n    /**\r\n     * This method returns a variable by name\r\n     * @param name the name of a specific variable\r\n     * @returns\r\n     */\r\n    getByName = async (name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getVariableByName(name).then((result) => getEditorResponseData<Variable>(result));\r\n    };\r\n\r\n    /**\r\n     * This method creates a new variable\r\n     * @param parentId parent id of the created variable\r\n     * @param type type of the created variable\r\n     * @returns the new created variable id\r\n     */\r\n    create = async (parentId: string, type: VariableType) => {\r\n        const res = await this.#editorAPI;\r\n        return res.addVariable(parentId, type).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method removes a list of variables.\r\n     * \r\n     * All connectors linked to the variables will be unregistered.\r\n     * @param ids list of the variables to be removed\r\n     * @returns\r\n     */\r\n    remove = async (ids: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.removeVariables(ids).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets a new name for a variable\r\n     * @param id id of the variable\r\n     * @param name name of the variable\r\n     * @returns\r\n     */\r\n    rename = async (id: string, name: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableName(id, name).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets a new label for a variable\r\n     * @param id id of the variable\r\n     * @param label label of the variable\r\n     * @returns\r\n     */\r\n    setLabel = async (id: string, label: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableLabel(id, label).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets a new type for a variable\r\n     * @param id id of the variable\r\n     * @param type type of the variable\r\n     * @returns\r\n     */\r\n    setType = async (id: string, type: VariableType) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableType(id, type).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the items of the list variable\r\n     *\r\n     * The items need to be unique and are not case sensitive.\r\n     *\r\n     * @param id the id of the list variable\r\n     * @param items the items of the list\r\n     * @returns\r\n     */\r\n    setListVariable = async (id: Id, items: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setListVariableItems(id, items).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets a new value for a variable\r\n     *\r\n     * @param id the id of the variable\r\n     * @param value the new value of the variable\r\n     * @returns\r\n     */\r\n    setValue = async (id: Id, value: string | boolean | null) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableValue(id, value).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method creates a copy of a variable\r\n     * @returns\r\n     */\r\n    duplicate = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.duplicateVariable(id).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method aggregates the provided variables into a new group\r\n     * @param name name of the new group\r\n     * @param ids list of variable ids to group together\r\n     * @returns group id\r\n     */\r\n    groupVariables = async (name: string, ids: string[]) => {\r\n        const res = await this.#editorAPI;\r\n        return res.groupVariables(name, ids).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method dissolves the specified group\r\n     * @param id id of the variable group\r\n     * @returns\r\n     */\r\n    ungroupVariables = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.ungroupVariable(id).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method moves a variable's position\r\n     * @param order new order of variable\r\n     * @param id id of the variable\r\n     * @param parentId parent id of the created variable\r\n     * @returns\r\n     */\r\n    move = async (order: number, id: string, parentId: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.moveVariable(id, parentId, order).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method changes positions of variables\r\n     * @param order new order of variable\r\n     * @param ids Array of the variable IDs\r\n     * @param parentId parent id of the variables\r\n     * @returns\r\n     */\r\n    moveVariables = async (order: number, ids: string[], parentId: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res\r\n            .moveVariables(ids, parentId, order)\r\n            .then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets isVisible flag for a variable\r\n     * @returns\r\n     */\r\n    setIsVisible = async (id: string, isVisible: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableIsVisible(id, isVisible).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * @deprecated Use `setIsVisible` instead.\r\n     * \r\n     * This method sets isHidden flag for a variable\r\n     * @returns\r\n     */\r\n    setIsHidden = async (id: string, isHidden: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableIsVisible(id, !isHidden).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets isRequired flag for a variable\r\n     * @returns\r\n     */\r\n    setIsRequired = async (id: string, isRequired: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableIsRequired(id, isRequired).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets isReadonly flag for a variable\r\n     * @returns\r\n     */\r\n    setIsReadonly = async (id: string, isReadonly: boolean) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setVariableIsReadonly(id, isReadonly).then((result) => getEditorResponseData<null>(result));\r\n    };\r\n\r\n    /**\r\n     * This method gets the image variable connector id.\r\n     * @param id The id of the image variable\r\n     * @returns The id of the connector\r\n     */\r\n    getImageVariableConnectorId = async (id: string) => {\r\n        const res = await this.#editorAPI;\r\n        return res.getImageVariableConnectorId(id).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * This method sets the image variable connector. Setting a connector will\r\n     * automatically remove the assetId linked to the connector if present.\r\n     * If a connector was the source of the variable, it will be unregistered.\r\n     * @param id The id of the image variable to update\r\n     * @param registration registration object containing all details about the connector\r\n     * @returns The new id of the connector\r\n     */\r\n    setImageVariableConnector = async (id: string, registration: ConnectorRegistration) => {\r\n        const res = await this.#editorAPI;\r\n        return res.setImageVariableConnector(id, JSON.stringify(registration)).then((result) => getEditorResponseData<Id>(result));\r\n    };\r\n\r\n    /**\r\n     * @deprecated use `setValue` instead and pass `null` as the value argument.\r\n     *\r\n     * This method removes the variable source\r\n     * @param id the id of the variable to update\r\n     */\r\n    removeSource = async (id: string) => {\r\n        return this.setValue(id, null);\r\n    };\r\n}\r\n","import engineInfo from '../../editor-engine.json';\r\nimport sdkInfo from '../../package.json';\r\n\r\n/**\r\n * The InfoController is responsible for getting info on the engine, like version f.e. .\r\n * Methods and properties inside this controller can be accessed by `window.SDK.engine.{name}`\r\n */\r\nexport class InfoController {\r\n    /**\r\n     * This property returns the current engine version.\r\n     * @returns current engine version\r\n     */\r\n    currentEngineVersion = engineInfo.current;\r\n\r\n    /**\r\n     * @returns The currently applicable SDK version\r\n     */\r\n    currentSDKVersion = sdkInfo.version;\r\n}\r\n","import { Connection } from 'penpal';\r\nimport Connect from './interactions/connector';\r\nimport { defaultStudioOptions, WellKnownConfigurationKeys } from './types/ConfigurationTypes';\r\nimport packageInfo from '../package.json';\r\nimport engineInfo from '../editor-engine.json';\r\n\r\nimport type { ConfigType, EditorAPI } from './types/CommonTypes';\r\nimport { DocumentType } from './types/DocumentTypes';\r\n\r\nimport { ActionController } from './controllers/ActionController';\r\nimport { AnimationController } from './controllers/AnimationController';\r\nimport { CanvasController } from './controllers/CanvasController';\r\nimport { CharacterStyleController } from './controllers/CharacterStyleController';\r\nimport { ColorStyleController } from './controllers/ColorStyleController';\r\nimport { ColorConversionController } from './controllers/ColorConversionController';\r\nimport { ConfigurationController } from './controllers/ConfigurationController';\r\nimport { ConnectorController } from './controllers/ConnectorController';\r\nimport { DebugController } from './controllers/DebugController';\r\nimport { DocumentController } from './controllers/DocumentController';\r\nimport { ExperimentController } from './controllers/ExperimentController';\r\nimport { FontConnectorController } from './controllers/FontConnectorController';\r\nimport { FontController } from './controllers/FontController';\r\nimport { FrameController } from './controllers/FrameController';\r\nimport { LayoutController } from './controllers/LayoutController';\r\nimport { MediaConnectorController } from './controllers/MediaConnectorController';\r\nimport { PageController } from './controllers/PageController';\r\nimport { ParagraphStyleController } from './controllers/ParagraphStyleController';\r\nimport { SubscriberController } from './controllers/SubscriberController';\r\nimport { TextStyleController } from './controllers/TextStyleController';\r\nimport { ToolController } from './controllers/ToolController';\r\nimport { UndoManagerController } from './controllers/UndoManagerController';\r\nimport { UtilsController } from './controllers/UtilsController';\r\nimport { VariableController } from './controllers/VariableController';\r\nimport { ShapeController } from './controllers/ShapeController';\r\nimport { InfoController } from './controllers/InfoController';\r\n\r\nlet connection: Connection;\r\n\r\nconst FIXED_EDITOR_LINK = 'https://studio-cdn.chiligrafx.com/editor/' + engineInfo.current + '/web';\r\n\r\nexport class SDK {\r\n    config: ConfigType;\r\n    connection: Connection;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    editorAPI: EditorAPI;\r\n\r\n    action: ActionController;\r\n    layout: LayoutController;\r\n    frame: FrameController;\r\n    shape: ShapeController;\r\n    connector: ConnectorController;\r\n    mediaConnector: MediaConnectorController;\r\n    fontConnector: FontConnectorController;\r\n    animation: AnimationController;\r\n    document: DocumentController;\r\n    configuration: ConfigurationController;\r\n    variable: VariableController;\r\n    utils: UtilsController;\r\n    tool: ToolController;\r\n    page: PageController;\r\n    debug: DebugController;\r\n    undoManager: UndoManagerController;\r\n    textSelection: TextStyleController;\r\n    paragraphStyle: ParagraphStyleController;\r\n    characterStyle: CharacterStyleController;\r\n    colorStyle: ColorStyleController;\r\n    font: FontController;\r\n    experiment: ExperimentController;\r\n    canvas: CanvasController;\r\n    colorConversion: ColorConversionController;\r\n    info: InfoController;\r\n\r\n    private subscriber: SubscriberController;\r\n\r\n    /**\r\n     * The SDK should be configured clientside and it exposes all controllers to work with in other applications\r\n     * @param config The configuration object where the SDK and editor can get configured\r\n     */\r\n    constructor(config: ConfigType) {\r\n        this.config = config;\r\n        this.connection = connection;\r\n        this.editorAPI = connection?.promise.then((child) => {\r\n            return child;\r\n        }) as unknown as EditorAPI;\r\n\r\n        this.action = new ActionController(this.editorAPI);\r\n        this.layout = new LayoutController(this.editorAPI);\r\n        this.frame = new FrameController(this.editorAPI);\r\n        this.shape = new ShapeController(this.editorAPI);\r\n        this.undoManager = new UndoManagerController(this.editorAPI, this);\r\n        this.connector = new ConnectorController(this.editorAPI);\r\n        this.mediaConnector = new MediaConnectorController(this.editorAPI);\r\n        this.fontConnector = new FontConnectorController(this.editorAPI);\r\n        this.animation = new AnimationController(this.editorAPI);\r\n        this.document = new DocumentController(this.editorAPI);\r\n        this.configuration = new ConfigurationController(this.editorAPI);\r\n        this.variable = new VariableController(this.editorAPI);\r\n        this.utils = new UtilsController();\r\n        this.subscriber = new SubscriberController(this.config);\r\n        this.tool = new ToolController(this.editorAPI);\r\n        this.page = new PageController(this.editorAPI);\r\n        this.debug = new DebugController(this.editorAPI);\r\n        // To be renamed textSelection > textStyle\r\n        this.textSelection = new TextStyleController(this.editorAPI);\r\n        this.colorStyle = new ColorStyleController(this.editorAPI);\r\n        this.paragraphStyle = new ParagraphStyleController(this.editorAPI);\r\n        this.characterStyle = new CharacterStyleController(this.editorAPI);\r\n        this.font = new FontController(this.editorAPI);\r\n        this.experiment = new ExperimentController(this.editorAPI);\r\n        this.canvas = new CanvasController(this.editorAPI);\r\n        this.colorConversion = new ColorConversionController(this.editorAPI);\r\n        this.info = new InfoController();\r\n    }\r\n\r\n    /**\r\n     * This method will initiate the editor, running this will result in the editor restarting\r\n     * It will generate an iframe in the document\r\n     */\r\n    loadEditor = () => {\r\n        Connect(\r\n            this.config.editorLink || FIXED_EDITOR_LINK,\r\n            {\r\n                onActionsChanged: this.subscriber.onActionsChanged,\r\n                onStateChanged: this.subscriber.onStateChanged,\r\n                onDocumentLoaded: this.subscriber.onDocumentLoaded,\r\n                onSelectedFrameContentChanged: this.subscriber.onSelectedFrameContentChanged,\r\n                onSelectedFrameLayoutChanged: this.subscriber.onSelectedFrameLayoutChanged,\r\n                onSelectedLayoutPropertiesChanged: this.subscriber.onSelectedLayoutPropertiesChanged,\r\n                onPageSelectionChanged: this.subscriber.onPageSelectionChanged,\r\n                onScrubberPositionChanged: this.subscriber.onAnimationPlaybackChanged,\r\n                onFrameAnimationsChanged: this.subscriber.onAnimationChanged,\r\n                onVariableListChanged: this.subscriber.onVariableListChanged,\r\n                onSelectedToolChanged: this.subscriber.onSelectedToolChanged,\r\n                onUndoStateChanged: this.subscriber.onUndoStateChanged,\r\n                onSelectedLayoutFramesChanged: this.subscriber.onSelectedLayoutFramesChanged,\r\n                onSelectedTextStyleChanged: this.subscriber.onSelectedTextStyleChanged,\r\n                onColorsChanged: this.subscriber.onColorsChanged,\r\n                onParagraphStylesChanged: this.subscriber.onParagraphStylesChanged,\r\n                onCharacterStylesChanged: this.subscriber.onCharacterStylesChanged,\r\n                onFontFamiliesChanged: this.subscriber.onFontFamiliesChanged,\r\n                onSelectedLayoutIdChanged: this.subscriber.onSelectedLayoutIdChanged,\r\n                onLayoutsChanged: this.subscriber.onLayoutsChanged,\r\n                onConnectorEvent: this.subscriber.onConnectorEvent,\r\n                onZoomChanged: this.subscriber.onZoomChanged,\r\n                onPageSizeChanged: this.subscriber.onPageSizeChanged,\r\n                onShapeCornerRadiusChanged: this.subscriber.onShapeCornerRadiusChanged,\r\n                onCropActiveFrameIdChanged: this.subscriber.onCropActiveFrameIdChanged,\r\n                onAsyncError: this.subscriber.onAsyncError,\r\n            },\r\n            this.setConnection,\r\n            this.config.editorId,\r\n            this.config.studioStyling,\r\n        );\r\n        this.editorAPI = connection?.promise.then((editorAPI) => {\r\n            return editorAPI;\r\n        }) as unknown as EditorAPI;\r\n\r\n        this.action = new ActionController(this.editorAPI);\r\n        this.layout = new LayoutController(this.editorAPI);\r\n        this.frame = new FrameController(this.editorAPI);\r\n        this.animation = new AnimationController(this.editorAPI);\r\n        this.document = new DocumentController(this.editorAPI);\r\n        this.configuration = new ConfigurationController(this.editorAPI);\r\n        this.utils = new UtilsController();\r\n        this.tool = new ToolController(this.editorAPI);\r\n        this.page = new PageController(this.editorAPI);\r\n        this.debug = new DebugController(this.editorAPI);\r\n        this.undoManager = new UndoManagerController(this.editorAPI, this);\r\n        this.textSelection = new TextStyleController(this.editorAPI);\r\n        this.colorStyle = new ColorStyleController(this.editorAPI);\r\n        this.paragraphStyle = new ParagraphStyleController(this.editorAPI);\r\n        this.characterStyle = new CharacterStyleController(this.editorAPI);\r\n        this.mediaConnector = new MediaConnectorController(this.editorAPI);\r\n        this.fontConnector = new FontConnectorController(this.editorAPI);\r\n        this.connector = new ConnectorController(this.editorAPI);\r\n        this.variable = new VariableController(this.editorAPI);\r\n        this.font = new FontController(this.editorAPI);\r\n        this.experiment = new ExperimentController(this.editorAPI);\r\n        this.canvas = new CanvasController(this.editorAPI);\r\n        this.shape = new ShapeController(this.editorAPI);\r\n        this.info = new InfoController();\r\n\r\n        // as soon as the editor loads, provide it with the SDK version\r\n        // used to make it start. This enables engine compatibility checks\r\n        // on the Flutter side\r\n        this.configuration.setValue(WellKnownConfigurationKeys.GraFxStudioSdkVersion, packageInfo.version);\r\n\r\n        // Makes the engine aware which document type it should render, if this call\r\n        // isn't made, the engine will fall back to the type specified in the document.\r\n        //\r\n        // Loading a template JSON and setting the engine to `project` will cause\r\n        // the document JSON structure to be converted to a project on save.\r\n        // Using `getCurrentDocumentState` will also output the converted document.\r\n        this.configuration.setValue(\r\n            WellKnownConfigurationKeys.GraFxStudioDocumentType,\r\n            this.config.documentType || DocumentType.template,\r\n        );\r\n\r\n        // Update the engine with the specified options from the config or fall back to the defaults.\r\n        this.configuration.updateStudioOptions(this.config.studioOptions || defaultStudioOptions);\r\n    };\r\n\r\n    setConnection = (newConnection: Connection) => {\r\n        connection = newConnection;\r\n    };\r\n}\r\n\r\nexport default SDK;\r\n","import { Id } from './CommonTypes';\r\n\r\nexport enum SlideDirections {\r\n    top = 'top',\r\n    left = 'left',\r\n    right = 'right',\r\n    bottom = 'bottom',\r\n    topLeft = 'topLeft',\r\n    topRight = 'topRight',\r\n    bottomLeft = 'bottomLeft',\r\n    bottomRight = 'bottomRight',\r\n}\r\n\r\nexport enum ShakeDirections {\r\n    horizontal = 'horizontal',\r\n    vertical = 'vertical',\r\n}\r\n\r\nexport enum EaseTypes {\r\n    easeIn = 'easeIn',\r\n    easeOut = 'easeOut',\r\n    easeInOut = 'easeInOut',\r\n}\r\n\r\nexport enum TweenTypes {\r\n    quadratic = 'Quadratic',\r\n    cubic = 'Cubic',\r\n    quartic = 'Quartic',\r\n    quintic = 'Quintic',\r\n    sine = 'Sine',\r\n    exponential = 'Exponential',\r\n    circular = 'Circular',\r\n    elastic = 'Elastic',\r\n    bounce = 'Bounce',\r\n    back = 'Back',\r\n}\r\n\r\nexport enum BasicAnimationsEmphasisStyles {\r\n    bounce = 'bounce',\r\n    flash = 'flash',\r\n    headshake = 'headShake',\r\n    heartbeat = 'heartbeat',\r\n    pulse = 'pulse',\r\n    rubberBand = 'rubberBand',\r\n    vertical = 'vertical',\r\n    horizontal = 'horizontal',\r\n    swing = 'swing',\r\n    tada = 'tada',\r\n}\r\n\r\nexport type EaseTweenCombinationType = `${EaseTypes}${TweenTypes}` | 'noEase';\r\n\r\nexport type BasicAnimationsIntroOutroStylesType = {\r\n    slide?: {\r\n        direction: SlideDirections;\r\n        offsetPercent: number;\r\n    };\r\n    rotation?: {\r\n        angleDegrees: number;\r\n        numberOfRotations?: number;\r\n    };\r\n    scale?: {\r\n        scalePercent: number;\r\n    };\r\n    fade?: boolean;\r\n};\r\n\r\nexport type BasicAnimationsIntroType = {\r\n    from: number;\r\n    to: number;\r\n    ease: EaseTweenCombinationType;\r\n    styles: BasicAnimationsIntroOutroStylesType;\r\n};\r\n\r\nexport type BasicAnimationsEmphasisType = {\r\n    from: number;\r\n    to: number;\r\n    ease: EaseTweenCombinationType;\r\n    styles: {\r\n        bounce?: boolean;\r\n        flash?: boolean;\r\n        pulse?: boolean;\r\n        rubberBand?: boolean;\r\n        shake?: {\r\n            direction: ShakeDirections;\r\n        };\r\n        vertical?: boolean;\r\n        horizontal?: boolean;\r\n        headshake?: boolean;\r\n        swing?: boolean;\r\n        tada?: boolean;\r\n        heartbeat?: boolean;\r\n    };\r\n};\r\n\r\nexport type BasicAnimationsOutroType = {\r\n    from: number;\r\n    to: number;\r\n    ease: EaseTweenCombinationType;\r\n    styles: BasicAnimationsIntroOutroStylesType;\r\n};\r\n\r\nexport type BasicAnimationsType = {\r\n    intro?: BasicAnimationsIntroType;\r\n    emphasis?: BasicAnimationsEmphasisType;\r\n    outro?: BasicAnimationsOutroType;\r\n};\r\n\r\nexport type FrameAnimationPropertiesType = {\r\n    id: Id;\r\n    from: number;\r\n    to: number;\r\n    basicAnimations: BasicAnimationsType;\r\n    advancedAnimations?: unknown; // TBI\r\n};\r\nexport type FrameAnimationType = {\r\n    animation: FrameAnimationPropertiesType;\r\n    isOverride: boolean;\r\n};\r\n\r\nexport type AnimationPlaybackType = {\r\n    currentAnimationTimeMs: number;\r\n    animationIsPlaying: boolean;\r\n} | null;\r\n","import { Id, PropertyState } from './CommonTypes';\r\n\r\nexport type LayoutPropertiesType = {\r\n    id: Id;\r\n    width: { value: number; isOverride: boolean };\r\n    height: { value: number; isOverride: boolean };\r\n    timelineLengthMs: { value: number; isOverride: boolean };\r\n    [key: string]: number | string | Record<string, unknown>;\r\n} | null;\r\n\r\nexport type FrameProperties = {\r\n    id: Id;\r\n    type: string;\r\n    height: number | null;\r\n    isVisible: boolean | null;\r\n    rotationDegrees: number | null;\r\n    scaleX: number | null;\r\n    scaleY: number | null;\r\n    width: number | null;\r\n    x: number | null;\r\n    y: number | null;\r\n};\r\n\r\nexport type LayoutWithFrameProperties = {\r\n    id: Id;\r\n    name: string;\r\n    parentId?: Id;\r\n    frameProperties: FrameProperties[];\r\n    width: number | null;\r\n    height: number | null;\r\n    childLayouts: Id[];\r\n    type: LayoutType;\r\n    timelineLengthMs?: number;\r\n    children?: LayoutWithFrameProperties[];\r\n};\r\n\r\n// used by new getter methods\r\nexport type Layout = {\r\n    id: Id;\r\n    name: string;\r\n    parentId?: Id;\r\n    width: PropertyState<number>;\r\n    height: PropertyState<number>;\r\n    childLayouts: Id[];\r\n    timelineLengthMs: PropertyState<number>;\r\n    unit: PropertyState<MeasurementUnit>;\r\n};\r\n\r\n// used by onLayoutsChanged\r\nexport type LayoutListItemType = {\r\n    id: string;\r\n    name: string;\r\n    type: LayoutType;\r\n    parentId?: Id | null;\r\n    childLayouts: Id[];\r\n};\r\n\r\nexport enum LayoutType {\r\n    top = 'top',\r\n    child = 'child',\r\n}\r\n\r\nexport enum MeasurementUnit {\r\n    px = 'px',\r\n    mm = 'mm',\r\n    cm = 'cm',\r\n    inch = 'inch',\r\n    pt = 'pt',\r\n}","\r\n\r\nexport interface ConnectorImageVariableSource {\r\n    connectorId: string;\r\n    assetId: string;\r\n}\r\n\r\n\r\nexport enum VariableType {\r\n    shortText = 'shortText',\r\n    longText = 'longText',\r\n    image = 'image',\r\n    list = 'list',\r\n    boolean = 'boolean',\r\n    group = 'group',\r\n}\r\n\r\nexport interface Variable {\r\n    id: string;\r\n    type: VariableType;\r\n    parentId?: string;\r\n    name: string;\r\n    label: string;\r\n    isVisible: boolean;\r\n    isReadonly: boolean;\r\n    isRequired: boolean;\r\n    occurrences: number;\r\n}\r\n\r\nexport interface ImageVariable extends Variable {\r\n    value?: ConnectorImageVariableSource;\r\n}\r\n\r\nexport interface ListVariable extends Variable {\r\n    items: string[];\r\n    selected?: string;\r\n}\r\n\r\nexport interface BooleanVariable extends Variable {\r\n    value: boolean;\r\n}\r\n\r\nexport interface ShortTextVariable extends Variable {\r\n    value: string;\r\n}\r\n\r\nexport type LongTextVariable = ShortTextVariable;\r\n\r\nexport type GroupVariable = Variable;\r\n","import { VerticalAlign } from './FrameTypes';\r\nimport { ColorUsage } from './ColorStyleTypes';\r\n\r\nexport enum FontWeights {\r\n    BOLD = 'Bold',\r\n    ITALIC = 'Italic',\r\n    REGULAR = 'Regular',\r\n}\r\nexport enum Alignment {\r\n    LEFT = 'left',\r\n    CENTER = 'center',\r\n    RIGHT = 'right',\r\n    JUSTIFY = 'justify',\r\n}\r\n\r\nexport enum TextPosition {\r\n    TOP = 'top',\r\n    CENTER = 'center',\r\n    BOTTOM = 'bottom',\r\n}\r\nexport enum Case {\r\n    TO_LOWER_CASE = 'lowercase',\r\n    TO_UPPER_CASE = 'uppercase',\r\n    NORMAL = 'normal',\r\n}\r\nexport enum Scripting {\r\n    SUPERSCRIPT = 'superscript',\r\n    SUBSCRIPT = 'subscript',\r\n    NORMAL = 'normal',\r\n}\r\n\r\nexport type DisplayColor = ColorUsage & {\r\n    isApplied: boolean;\r\n};\r\nexport interface TextProperties {\r\n    fontKey?: string;\r\n    fontStyle?: FontWeights;\r\n    fontSize?: number;\r\n    textAlign?: Alignment;\r\n    verticalAlign?: VerticalAlign;\r\n    underline?: boolean;\r\n    lineThrough?: boolean;\r\n    letterSpacing?: string;\r\n    lineHeight?: number;\r\n    SUB_SUPER_SCRIPT?: Scripting;\r\n    typographicCase?: Case;\r\n    color?: DisplayColor;\r\n    [key: string]: number | string | Record<string, unknown> | null | boolean | undefined;\r\n}\r\n\r\nexport interface TextStyle {\r\n    paragraph?: string;\r\n    character?: string;\r\n    [key: string]: number | string | Record<string, unknown> | null | boolean | undefined;\r\n}\r\nexport type TextStyleUpdateType = {\r\n    [key in keyof typeof SelectedTextStyles]?: {\r\n        value: number | string | boolean;\r\n    };\r\n};\r\n\r\nexport interface AppearanceProperties {\r\n    blendMode?: string;\r\n    opacity?: string;\r\n    useFill?: boolean;\r\n    useStroke?: boolean;\r\n    useDropShadow?: boolean;\r\n    fillColor?: string;\r\n    strokeColor?: string;\r\n    dropShadowColor?: string;\r\n}\r\n\r\nexport interface SelectedTextStyle {\r\n    paragraphStyleId?: string;\r\n    characterStyleId?: string;\r\n    fontKey?: string;\r\n    fontSize: number;\r\n    typographicCase: Case;\r\n    kerningOn: boolean;\r\n    subSuperScript: Scripting;\r\n    trackingLeft: string;\r\n    trackingRight: string;\r\n    startIndent: string;\r\n    endIndent: string;\r\n    spaceBefore: string;\r\n    spaceAfter: string;\r\n    textIndent: string;\r\n    alignToBaseLine: boolean;\r\n    baselineShiftValue: string;\r\n    lineHeight: number;\r\n    verticalAlign: VerticalAlign;\r\n    copyfittingScale: number;\r\n    textAlign: HorizontalAlign;\r\n    textAlignLast: HorizontalAlign;\r\n    textOverprint: boolean;\r\n    color: DisplayColor;\r\n    underline: boolean;\r\n    lineThrough: boolean;\r\n}\r\n\r\nexport enum HorizontalAlign {\r\n    left = 'left',\r\n    center = 'center',\r\n    right = 'right',\r\n    justify = 'justify',\r\n}\r\n\r\nexport enum SelectedTextStyleSections {\r\n    STYLE = 'textStyle',\r\n    PROPERTIES = 'textProperties',\r\n    APPEARANCE = 'appearance',\r\n}\r\n\r\nexport enum SelectedTextStyles {\r\n    PARAGRAPH = 'paragraphStyleId',\r\n    CHARACTER = 'characterStyleId',\r\n    FONT_FAMILY = 'fontKey',\r\n    FONT_STYLE = 'fontStyle',\r\n    FONT_SIZE = 'fontSize',\r\n    LETTER_SPACING = 'letterSpacing',\r\n    LINE_HEIGHT = 'lineHeight',\r\n    TEXT_ALIGN = 'textAlign',\r\n    VERTICAL_ALIGN = 'verticalAlign',\r\n    TYPOGRAPHIC_CASE = 'typographicCase',\r\n    SUB_SUPER_SCRIPT = 'subSuperScript',\r\n    UNDERLINE = 'underline',\r\n    LINE_THROUGH = 'lineThrough',\r\n    FILL_COLOR = 'fillColor',\r\n    COLOR = 'color',\r\n    FILL_COLOR_APPLIED = 'fillColorApplied',\r\n    STROKE_COLOR = 'strokeColor',\r\n    DROP_SHADOW_COLOR = 'dropShadowColor',\r\n    BLEND_MODE = 'blendMode',\r\n    OPACITY = 'opacity',\r\n}\r\n\r\nexport interface UpdateStyleType {\r\n    path: { value: number | string | Record<string, unknown> | null | boolean | undefined };\r\n}\r\n","import { Id } from \"./CommonTypes\";\r\n\r\nexport enum ColorType {\r\n    rgb = 'rgb',\r\n    hex = 'hex',\r\n    cmyk = 'cmyk',\r\n    gray = 'gray',\r\n    hsl = 'hsl',\r\n    spot = 'spot',\r\n}\r\n\r\nexport type RGBColor = {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n    type: ColorType;\r\n};\r\n\r\nexport type CMYKColor = {\r\n    c: number;\r\n    m: number;\r\n    y: number;\r\n    k: number;\r\n    type: ColorType;\r\n};\r\n\r\nexport type HSLColor = {\r\n    h: number;\r\n    s: number;\r\n    l: number;\r\n    type: ColorType;\r\n};\r\n\r\nexport type GrayColor = {\r\n    g: number;\r\n    type: ColorType;\r\n};\r\n\r\nexport type SpotColor = {\r\n    spotName: string;\r\n    c: number;\r\n    m: number;\r\n    y: number;\r\n    k: number;\r\n    type: ColorType;\r\n};\r\n\r\nexport type HexColor = {\r\n    value: string;\r\n    type: ColorType;\r\n};\r\n\r\nexport type Color = RGBColor | CMYKColor | HSLColor | GrayColor | SpotColor | HexColor;\r\n\r\nexport type ColorUpdate = Color;\r\n\r\nexport type DocumentColor = {\r\n    id: string;\r\n    name: string;\r\n    color: Color;\r\n};\r\n\r\nexport type ColorUsageUpdate = {\r\n    /**\r\n     * Reference to the stylekit color, can only be used if it is a stylekit color.\r\n     */\r\n    id?: Id;\r\n    /**\r\n     * The local color object, can only be used if it is a local color.\r\n     */\r\n    color?: ColorUpdate;\r\n    type: ColorUsageType;\r\n    /**\r\n     * Opacity of the color (0-100) where 0 = fully transparent.\r\n     */\r\n    opacity?: number;\r\n    /**\r\n     * Indicates if the color will be applied or not.\r\n     */\r\n    isApplied?: boolean;\r\n};\r\n\r\nexport type ColorUsage = {\r\n    /**\r\n     * Reference to the stylekit color, can only be used if it is a stylekit color.\r\n     */\r\n    id?: Id;\r\n    /**\r\n     * The local color object, can only be used if it is a local color.\r\n     */\r\n    color?: Color;\r\n    type: ColorUsageType;\r\n    /**\r\n     * Opacity of the color (0-100) where 0 = fully transparent.\r\n     */\r\n    opacity?: number;\r\n};\r\n\r\nexport enum ColorUsageType {\r\n    /**\r\n     * The color is defined locally on the object\r\n     */\r\n    local = 'local',\r\n    /**\r\n     * THe color is referencing a stylekit color\r\n     */\r\n    stylekit = 'stylekit',\r\n}\r\n","import { Id } from './CommonTypes';\r\nimport { MediaType } from './ConnectorTypes';\r\n\r\nexport enum MediaDownloadType {\r\n    LowResolutionWeb = 'lowresWeb',\r\n    HighResolutionWeb = 'highresWeb',\r\n}\r\n\r\nexport type Media = {\r\n    id: Id;\r\n    name: string;\r\n    relativePath: string;\r\n    type: MediaType;\r\n    extension: string | null;\r\n    metaData: {\r\n        [key: string]: string;\r\n    };\r\n};\r\n\r\nexport type MediaPage = {\r\n    pageSize: number;\r\n    nextPageToken?: string;\r\n    data: Media[];\r\n};\r\n","import { Id } from './CommonTypes';\r\n\r\nexport enum FontPreviewFormat {\r\n    Square = 'square',\r\n    Line = 'line',\r\n}\r\n\r\nexport type FontFamily = {\r\n    id: Id;\r\n    name: string;\r\n    fontStylesCount: number;\r\n    extensions: string[];\r\n};\r\n\r\nexport type FontStyle = {\r\n    id: Id;\r\n    name: string;\r\n    familyId: string;\r\n    familyName: string;\r\n};\r\n\r\nexport type FontPage = {\r\n    pageSize: number;\r\n    nextPageToken?: string;\r\n    data: FontFamily[];\r\n};\r\n","import { Id } from './CommonTypes';\r\n\r\n/**\r\n * Editor Events that Actions can react to.\r\n */\r\nexport enum ActionEditorEvent {\r\n    /**\r\n     * Indicates the selected layout changed.\r\n     */\r\n    selectedLayoutChanged = 'selectedLayoutChanged',\r\n\r\n    /**\r\n     * Indicates a frame was moved, resized, rotated.\r\n     * Note: this does not trigger when a different layout is selected.\r\n     */\r\n    frameMoved = 'frameMoved',\r\n\r\n    /**\r\n     * Indicates the size of a page has changed.\r\n     */\r\n    pageSizeChanged = 'pageSizeChanged',\r\n\r\n    /**\r\n     * Indicates the document is fully initialized, actions can safely be executed.\r\n     * Note: the other events will only be triggered after a document is fully initialized.\r\n     */\r\n    documentLoaded = 'documentLoaded',\r\n\r\n    /**\r\n     * Indicates the value of a variable changed.\r\n     */\r\n    variableValueChanged = 'variableValueChanged',\r\n}\r\n\r\n/**\r\n * Action used by the document.\r\n */\r\nexport interface DocumentAction {\r\n    /**\r\n     * Unique Id of the action.\r\n     */\r\n    id: Id;\r\n\r\n    /**\r\n     * Unique action name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * All the triggers this action will react to.\r\n     */\r\n    triggers: ActionTrigger[];\r\n\r\n    /**\r\n     * The JavaScript based action script.\r\n     */\r\n    script: string;\r\n}\r\n\r\n/**\r\n * Trigger used to fire an action.\r\n */\r\nexport type ActionTrigger =\r\n    | SelectedLayoutChangedTrigger\r\n    | FrameMovedTrigger\r\n    | PageSizeChangedTrigger\r\n    | DocumentLoadedTrigger\r\n    | VariableValueChangedTrigger;\r\n\r\nexport interface SelectedLayoutChangedTrigger {\r\n    event: ActionEditorEvent.selectedLayoutChanged;\r\n}\r\n\r\nexport interface FrameMovedTrigger {\r\n    event: ActionEditorEvent.frameMoved;\r\n    /**\r\n     * The frame id's this trigger should react to.\r\n     * Leaving this `undefined`, will make this trigger react to any frame that moves in any direction (also rotation, resize and ).\r\n     */\r\n    triggers?: Id[];\r\n}\r\n\r\nexport interface PageSizeChangedTrigger {\r\n    event: ActionEditorEvent.pageSizeChanged;\r\n}\r\n\r\nexport interface DocumentLoadedTrigger {\r\n    event: ActionEditorEvent.documentLoaded;\r\n}\r\n\r\nexport interface VariableValueChangedTrigger {\r\n    event: ActionEditorEvent.variableValueChanged;\r\n\r\n    /**\r\n     * The variable id's this trigger should react to.\r\n     * Leaving this `undefined`, will make this trigger react to all variableValueChanges.\r\n     */\r\n    triggers?: Id[];\r\n}\r\n","import { ColorUsage } from './ColorStyleTypes';\r\n\r\nexport enum ShapeType {\r\n    ellipse = 'ellipse',\r\n    rectangle = 'rectangle',\r\n    polygon = 'polygon',\r\n}\r\n\r\nexport interface ShapeProperties {\r\n    enableFill?: boolean;\r\n    fillColor?: ColorUsage;\r\n    enableStroke?: boolean;\r\n    strokeColor?: ColorUsage;\r\n    strokeWeight?: number;\r\n    allCornersSame?: boolean;\r\n}\r\n\r\nexport interface CornerRadiusUpdateModel {\r\n    radiusAll?: number;\r\n    topLeft?: number;\r\n    bottomLeft?: number;\r\n    topRight?: number;\r\n    bottomRight?: number;\r\n}\r\n\r\nexport interface CornerRadiusNone {\r\n    type: string;\r\n}\r\n\r\nexport interface CornerRadiusAll {\r\n    type: string;\r\n    radius: number;\r\n}\r\n\r\nexport interface CornerRadiusOnly {\r\n    type: string;\r\n    topLeft: number;\r\n    bottomLeft: number;\r\n    topRight: number;\r\n    bottomRight: number;\r\n}\r\n\r\nexport enum CornerRadiusType {\r\n    all = 'all',\r\n    only = 'only',\r\n    none = 'none',\r\n}\r\n","import { SDK } from './sdk';\r\n\r\nexport { FramePropertyNames, LayoutPropertyNames, ToolType, DownloadFormats, EnvironmentType } from './utils/enums';\r\n\r\nexport {\r\n    SlideDirections,\r\n    ShakeDirections,\r\n    EaseTypes,\r\n    TweenTypes,\r\n    BasicAnimationsEmphasisStyles,\r\n} from './types/AnimationTypes';\r\nexport { LayoutType } from './types/LayoutTypes';\r\nexport {\r\n    BlendMode,\r\n    FrameTypeEnum,\r\n    VerticalAlign,\r\n    TextDirection,\r\n    FlowDirection,\r\n    FitMode,\r\n    UpdateZIndexMethod,\r\n    ImageSourceTypeEnum,\r\n} from './types/FrameTypes';\r\nexport { DocumentType } from './types/DocumentTypes';\r\n\r\nexport type {\r\n    LayoutPropertiesType,\r\n    FrameProperties,\r\n    LayoutWithFrameProperties,\r\n    LayoutListItemType,\r\n} from './types/LayoutTypes';\r\nexport type {\r\n    FrameLayoutType,\r\n    FrameType,\r\n    Frame,\r\n    TextFrame,\r\n    ImageFrame,\r\n    ShapeFrame,\r\n    ImageFrameSource,\r\n    ImageFrameVariableSource,\r\n    ImageFrameUrlSource,\r\n} from './types/FrameTypes';\r\nexport type {\r\n    Variable,\r\n    GroupVariable,\r\n    ImageVariable,\r\n    LongTextVariable,\r\n    ShortTextVariable,\r\n    ListVariable,\r\n    BooleanVariable,\r\n    ConnectorImageVariableSource,\r\n} from './types/VariableTypes';\r\nexport { VariableType } from './types/VariableTypes';\r\n\r\nexport type { Color, DocumentColor, ColorUpdate } from './types/ColorStyleTypes';\r\n\r\nexport type { DocumentError } from './types/DocumentTypes';\r\nexport type {\r\n    FrameAnimationType,\r\n    FrameAnimationPropertiesType,\r\n    EaseTweenCombinationType,\r\n    AnimationPlaybackType,\r\n    BasicAnimationsType,\r\n} from './types/AnimationTypes';\r\nexport type {\r\n    ConfigType,\r\n    InitialStateType,\r\n    PageType,\r\n    EditorResponse,\r\n    SelectedLayoutFrame,\r\n    MetaData,\r\n    Id,\r\n} from './types/CommonTypes';\r\n\r\nexport type {\r\n    TextProperties,\r\n    TextStyle,\r\n    AppearanceProperties,\r\n    TextStyleUpdateType,\r\n    UpdateStyleType,\r\n    DisplayColor,\r\n} from './types/TextStyleTypes';\r\n\r\nexport type { ParagraphStyle, ParagraphStyleUpdate } from './types/ParagraphStyleTypes';\r\nexport type { CharacterStyle, CharacterStyleUpdate } from './types/CharacterStyleTypes';\r\nexport type { ColorUsage, ColorUsageUpdate, ColorUsageType } from './types/ColorStyleTypes';\r\n\r\nexport type {\r\n    DocumentFontStyle,\r\n    DocumentFontFamily,\r\n    AddDocumentFontStyle,\r\n    AddDocumentFontFamily,\r\n} from './types/FontTypes';\r\n\r\nexport {\r\n    SelectedTextStyleSections,\r\n    SelectedTextStyles,\r\n    FontWeights,\r\n    Alignment,\r\n    TextPosition,\r\n    Case,\r\n    Scripting,\r\n} from './types/TextStyleTypes';\r\nexport { ColorType } from './types/ColorStyleTypes';\r\nexport * from './types/MediaConnectorTypes';\r\nexport * from './types/FontConnectorTypes';\r\nexport * from './types/ConnectorTypes';\r\n\r\nexport { WellKnownConfigurationKeys } from './types/ConfigurationTypes';\r\n\r\nexport * from './types/ActionTypes';\r\n\r\nexport * from './types/ShapeTypes';\r\n\r\nexport default SDK;\r\n"],"names":["root","factory","exports","module","define","amd","this","Resolution","ErrorCode","NativeErrorName","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","MessageType","NativeEventType","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","serializeError","name","message","stack","id","keyPathToSegments","keyPath","split","setAtKeyPath","subject","segments","reduce","prevSubject","idx","length","methods","prefix","flattenedMethods","keys","forEach","push","join","segmentsToKeyPath","createKeyPath","assign","callSender","info","methodKeyPaths","destroyConnection","log","destroyed","localName","createMethodProxy","methodName","args","iframeRemoved","remote","closed","e","error","Error","code","ConnectionDestroyed","Promise","resolve","reject","generateId","handleMessageEvent","event","source","data","penpal","origin","originForReceiving","replyMessage","local","removeEventListener","returnValue","returnValueIsError","deserializedError","deserializeError","resolution","Fulfilled","addEventListener","callMessage","postMessage","originForSending","api","deserializeMethods","serializedMethods","childOrigin","destructor","destroyCallReceiver","receiverMethodNames","window","createPromiseHandler","Rejected","err","DataCloneError","errorReplyMessage","apply","then","onDestroy","receiverMethodName","methodNames","destroyCallSender","destroy","options","debug","console","callbacks","callback","iframe","src","srcdoc","NoIframeSrc","validateIframeHasSrcOrSrcDoc","find","scheme","startsWith","location","document","regexResult","exec","protocol","hostname","port","getOriginFromSrc","handleSynMessage","synAckMessage","handleSynMessageFactory","handleAckMessage","handleAckMessageFactory","promise","stopConnectionTimeout","timeout","timeoutId","undefined","setTimeout","ConnectionTimeout","clearTimeout","handleMessage","contentWindow","checkIframeInDocIntervalId","setInterval","isConnected","clearInterval","monitorIframeRemoval","setupFrame","editorLink","styling","link","RegExp","test","indexOf","replace","charAt","validateEditorLink","html","JSON","stringify","iframeDoc","ownerDocument","open","write","close","params","setConnection","editorId","editorSelectorId","createElement","setAttribute","setupNewFrame","iframeContainer","querySelector","appendChild","readyState","connectToChild","actionsChanged","onActionsChanged","stateChanged","onStateChanged","documentLoaded","onDocumentLoaded","selectedFrameContent","onSelectedFrameContentChanged","selectedFrameLayout","onSelectedFrameLayoutChanged","selectedLayoutProperties","onSelectedLayoutPropertiesChanged","openLayoutPropertiesPanel","onPageSelectionChanged","scrubberPositionChanged","onScrubberPositionChanged","frameAnimationsChanged","onFrameAnimationsChanged","selectedToolChanged","onSelectedToolChanged","variableListChanged","onVariableListChanged","undoStackStateChanged","onUndoStateChanged","selectedLayoutFramesChanged","onSelectedLayoutFramesChanged","selectedTextStyleChanged","onSelectedTextStyleChanged","colorsChanged","onColorsChanged","paragraphStylesChanged","onParagraphStylesChanged","characterStylesChanged","onCharacterStylesChanged","fontFamiliesChanged","onFontFamiliesChanged","selectedLayoutId","onSelectedLayoutIdChanged","layoutListChanged","onLayoutsChanged","connectorEvent","onConnectorEvent","zoomChanged","onZoomChanged","pageSizeChanged","onPageSizeChanged","shapeCornerRadiusChanged","onShapeCornerRadiusChanged","cropActiveFrameIdChanged","onCropActiveFrameIdChanged","asyncError","onAsyncError","WellKnownConfigurationKeys","defaultStudioOptions","shortcutOptions","debugPanel","enabled","ellipse","hand","image","polygon","rectangle","select","text","zoom","ImageFrameSourceType","FramePropertiesType","DocumentType","getEditorResponseData","response","parse","success","cause","String","status","dataShouldBeParsed","parsedData","ActionController","constructor","editorAPI","getAll","getActions","result","getById","getActionById","create","createAction","duplicate","duplicateAction","remove","removeAction","rename","renameAction","updateScript","actionScript","updateActionScript","updateTriggers","triggers","updateActionTriggers","move","order","ids","moveActions","setTypeError","hasTypeErrors","setActionTypeError","AnimationController","children","getAllOnSelectedLayout","getAnimationsOnSelectedLayout","getByFrameId","layoutId","getAnimationByFrameId","getByLayoutId","getAnimationsByLayoutId","setFrameAnimation","animation","play","playAnimation","pause","pauseAnimation","setScrubberPosition","timeInMS","setDuration","setAnimationDuration","resetFrameAnimation","reset","resetAnimation","CanvasController","zoomToPage","left","top","width","height","getZoomPercentage","setZoomPercentage","scaleFactor","CharacterStyleController","getCharacterStyles","characterStyleId","getCharacterStyleById","createCharacterStyle","update","characterStyle","updateCharacterStyle","removeCharacterStyle","duplicateCharacterStyle","characterStyleName","renameCharacterStyle","ColorStyleController","getColors","getColorById","createColor","duplicateColor","moveColors","newColorName","renameColor","newColorProperties","updateColor","removeColor","ColorConversionController","convertToRgb","color","colorToRgb","DeprecatedMediaType","MediaType","ConnectorType","SortBy","SortOrder","ConnectorRegistrationSource","ConnectorMappingSource","ConnectorStateType","ConnectorEventType","ConfigurationController","getValue","getConfigValue","setValue","setConfigValue","updateStudioOptions","ConnectorMapping","contextProperty","mapFrom","sourceValue","variable","grafxMediaConnectorRegistration","url","ConnectorController","getConnectorById","getAllByType","type","getConnectors","register","registration","registerConnector","unregister","unregisterConnector","configure","configurationCallback","res","waitToBeReady","ConnectorConfigurator","updateConnectorConfiguration","getState","getConnectorState","getMappings","getConnectorMappings","getOptions","getConnectorOptions","timeoutMilliseconds","Math","max","min","retries","running","ready","setOptions","setConnectorOptions","setMappings","mappings","setConnectorMappings","map","m","setChiliToken","token","connectorAuthenticationSetChiliToken","setHttpHeader","headerName","headerValue","connectorAuthenticationSetHttpHeader","DebugController","getAllLogs","getLogs","toggleDebugPanel","enableDebug","disableDebug","ImageSourceTypeEnum","FrameTypeEnum","TextDirection","FlowDirection","VerticalAlign","BlendMode","FitMode","UpdateZIndexMethod","DocumentController","getCurrentState","getCurrentDocumentState","load","doc","keepConnectors","loadDocumentKeepConnectors","loadDocument","ExperimentController","insertImageVariableToFrame","imageFrameId","variableId","setImageSource","insertTextVariable","enterTextEditMode","exitTextEditMode","getText","frameId","textType","getTextByFrameId","setText","setTextByFrameId","selectText","startIndex","selectTextById","FontConnectorController","query","connectorId","queryOptions","context","fontConnectorQuery","detail","fontFamilyId","fontConnectorDetail","download","fontStyleId","fontConnectorDownload","preview","previewFormat","fontConnectorPreview","upload","blob","fontConnectorUpload","fontConnectorRemove","copy","newName","fontConnectorCopy","getConfigurationOptions","fontConnectorGetConfigurationOptions","getCapabilities","fontConnectorGetCapabilities","parseDeprecatedFontType","deprecatedType","file","collection","FontController","addFontFamily","fontFamily","removeFontFamily","addFontStyle","fontStyle","removeFontStyle","getFontFamilies","getFontStyles","getFontFamilyById","getFontStyleById","getDefaultFontStyle","isFontFamilyUsed","isFontStyleUsed","moveFontFamilies","ShapeController","setShapeProperties","properties","setEnableFill","enableFill","setFillColor","fillColor","setEnableStroke","enableStroke","setStrokeColor","strokeColor","setStrokeWeight","strokeWeight","setFlagAllCornersSame","allCornersSame","setShapeCorners","radius","setRadiusAll","cornerRadius","radiusAll","setRadiusTopLeft","topLeft","setRadiusBottomLeft","bottomLeft","setRadiusTopRight","topRight","setRadiusBottomRight","bottomRight","FrameController","getFrames","getSelected","getSelectedFrames","getAllByPageId","getFramesByPageId","getByName","getFrameByName","getFrameById","getPropertiesOnSelectedLayout","getFramePropertiesOnSelectedLayout","getLayoutProperties","getFramePropertiesByFrameId","getAllLayoutProperties","getFramesProperties","resetSize","resetFrameSize","selectFrames","selectMultiple","reorderFrames","setZIndex","method","setFrameZIndex","setHeight","setFrameHeight","setRotation","rotation","setFrameRotation","setWidth","setFrameWidth","setX","XValue","setFrameX","setY","YValue","setFrameY","renameFrame","resetFrame","resetX","resetFrameX","resetY","resetFrameY","resetRotation","resetFrameRotation","resetWidth","resetFrameWidth","resetHeight","resetFrameHeight","resetImageFrameFitMode","setVisibility","setFrameIsVisible","setIsVisible","removeFrame","x","y","addFrame","createShapeFrame","updateImageSource","srcJson","removeImageSource","setImageFromConnector","assetId","connector","setImageFromUrl","setImageFrameFitMode","fitMode","setFrameConstrainProportions","constrainProportions","setVerticalAlign","verticalAlign","setVerticalAlignment","setMinCopyfitting","setMaxCopyfitting","setEnableCopyfitting","resetMinCopyfitting","resetMaxCopyfitting","resetEnableCopyfitting","setShapeFrameEnableFill","shapeFrameId","shapeController","setShapeFrameFillColor","setShapeFrameEnableStroke","setShapeFrameStrokeColor","setShapeFrameStrokeWeight","setBlendMode","blendMode","setFrameBlendMode","enterCropMode","applyCropMode","resetCropMode","exitCropMode","cancelCropMode","LayoutController","getLayouts","getLayoutById","getLayoutByName","getSelectedLayout","removeLayout","parentId","addLayout","renameLayout","selectLayout","duplicateLayout","resetLayout","setLayoutHeight","setLayoutWidth","resetLayoutHeight","resetLayoutWidth","getSelectedSnapshot","getPageSnapshot","MediaConnectorController","mediaConnectorQuery","mediaId","mediaConnectorDetail","downloadType","mediaConnectorDownload","mediaConnectorUpload","mediaConnectorRemove","mediaConnectorCopy","mediaConnectorGetConfigurationOptions","mediaConnectorGetCapabilities","parseDeprecatedMediaType","PageController","getPages","getPageById","setPageWidth","setPageHeight","ParagraphStyleController","getParagraphStyles","getParagraphStyleById","createParagraphStyle","duplicateParagraphStyle","updateParagraphStyle","renameParagraphStyle","removeParagraphStyle","moveParagraphStyles","SubscriberController","config","actions","callBack","onAnimationChanged","onAnimationPlaybackChanged","animationPlaybackState","layoutProperties","frameLayout","frameContent","variablesJson","tool","undoState","onUndoStackStateChanged","layoutFrames","styles","colors","paragraphStyles","characterStyles","fonts","layouts","pageSize","FramePropertyNames","LayoutPropertyNames","ToolType","DownloadFormats","EnvironmentType","TextStyleController","set","style","selectedTextStyleDeltaUpdate","removeSelected","selectedTextStyleClean","getSelectedTextStyle","ToolController","setTool","getSelectedTool","setPointer","SELECT","setHand","HAND","setZoom","ZOOM","setTextFrame","TEXT_FRAME","setImageFrame","IMAGE_FRAME","setShapeRect","SHAPE_RECT","setShapeEllipse","SHAPE_ELLIPSE","setShapePolygon","SHAPE_POLYGON","UndoManagerController","sdk","undo","redo","record","operationName","undoOperationCallback","begin","end","AdvancedUndoManagerController","beginIfNoneActive","round","val","precision","hundred","pow","UtilsController","createEnvironmentBaseURL","parameters","SANDBOX","environment","version","VariableController","getVariables","getVariableById","getVariableByName","addVariable","removeVariables","setVariableName","setLabel","label","setVariableLabel","setType","setVariableType","setListVariable","items","setListVariableItems","setVariableValue","duplicateVariable","groupVariables","ungroupVariables","ungroupVariable","moveVariable","moveVariables","isVisible","setVariableIsVisible","setIsHidden","isHidden","setIsRequired","isRequired","setVariableIsRequired","setIsReadonly","isReadonly","setVariableIsReadonly","getImageVariableConnectorId","setImageVariableConnector","removeSource","InfoController","currentEngineVersion","currentSDKVersion","connection","FIXED_EDITOR_LINK","SDK","loadEditor","subscriber","studioStyling","action","layout","frame","configuration","utils","page","undoManager","textSelection","colorStyle","paragraphStyle","mediaConnector","fontConnector","font","experiment","canvas","shape","GraFxStudioSdkVersion","GraFxStudioDocumentType","documentType","template","studioOptions","newConnection","child","colorConversion","SlideDirections","ShakeDirections","EaseTypes","TweenTypes","BasicAnimationsEmphasisStyles","LayoutType","MeasurementUnit","VariableType","FontWeights","Alignment","TextPosition","Case","Scripting","HorizontalAlign","SelectedTextStyleSections","SelectedTextStyles","ColorType","ColorUsageType","MediaDownloadType","FontPreviewFormat","ActionEditorEvent","ShapeType","CornerRadiusType"],"sourceRoot":""}