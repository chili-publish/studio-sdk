name: Create GitHub Release

on:
  push:
    branches:
      - fix/WRS-2503-test-branch-use-case
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment (uat or prd)"
        required: true
        type: choice
        options:
          - uat
          - prd
      release_type:
        description: "Release type (regular or hotfix)"
        required: true
        type: choice
        options:
          - regular
          - hotfix
      engine_version:
        description: "Engine version to use (e.g., 2.15.latest) - optional (UAT regular only)"
        required: false
        type: string

env:
  NODE_VERSION: 22.x

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      environment: ${{ steps.prepare.outputs.environment }}
      release_type: ${{ steps.prepare.outputs.release_type }}
      engine_version: ${{ steps.prepare.outputs.engine_version }}
    steps:
      - name: Prepare release parameters
        id: prepare
        run: |
          # Extract values from inputs (workflow_dispatch) or use defaults (push for testing)
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            # Default values for testing (branch push trigger)
            ENVIRONMENT="uat"
          fi

          if [ -n "${{ github.event.inputs.release_type }}" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Default values for testing (branch push trigger)
            RELEASE_TYPE="regular"
          fi

          if [ -n "${{ github.event.inputs.engine_version }}" ]; then
            ENGINE_VERSION="${{ github.event.inputs.engine_version }}"
          else
            # Default empty for testing (branch push trigger)
            ENGINE_VERSION=""
          fi

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "engine_version=$ENGINE_VERSION" >> $GITHUB_OUTPUT

  uat-regular:
    needs: setup
    if: needs.setup.outputs.environment == 'uat' && needs.setup.outputs.release_type == 'regular'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      notification_text: ${{ steps.notify.outputs.text }}
    steps:
      - name: Get GitHub App Access Token
        id: github-app-access-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
          owner: ${{ github.repository_owner }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          token: ${{ steps.github-app-access-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fetch and cache GitHub Releases
        run: |
          gh release list --limit 10 --json isPrerelease,tagName | jq '.' > /tmp/releases.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Find previous release tag
        id: previous_tag
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # For UAT regular: always use the latest production release as previous tag
          PREVIOUS_TAG=$(jq -r '.[] | select(.isPrerelease == false) | .tagName' /tmp/releases.json | head -1)

          if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" = "null" ]; then
            echo "âŒ Error: No production release found. A previous production release is required for UAT regular releases."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Store workflow execution branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          echo "workflow_branch=$WORKFLOW_BRANCH" >> $GITHUB_ENV

      - name: Bump version in memory
        id: bump_version
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # UAT regular: add -rc.0 prefix (minor version already bumped in post-production step)
          # e.g., 1.3.0-alpha.0 -> 1.3.0-rc.0
          NEW_VERSION=$(npm version prerelease --preid=rc --git-tag-version=false)

          # Remove 'v' prefix if present
          TAG_NAME=$(echo $NEW_VERSION | sed 's/^v//')
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Execute replicate version script
        run: node ./.github/scripts/replicate-version.js

      - name: Update engine version
        if: needs.setup.outputs.engine_version != ''
        run: |
          ENGINE_VERSION="${{ needs.setup.outputs.engine_version }}"
          ENGINE_JSON="packages/sdk/editor-engine.json"

          # Update the engine version in editor-engine.json
          node -e "
            const fs = require('fs');
            const path = '$ENGINE_JSON';
            const data = JSON.parse(fs.readFileSync(path, 'utf8'));
            data.current = '$ENGINE_VERSION';
            fs.writeFileSync(path, JSON.stringify(data, null, 4));
          "

      - name: Commit version changes
        id: commit_version
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"

          # Create a version branch for the version commit
          VERSION_BRANCH="temp-release-$(date +%s)"
          git checkout -b "$VERSION_BRANCH"
          echo "version_branch=$VERSION_BRANCH" >> $GITHUB_ENV

          # Stage version-related files
          git add package.json packages/*/package.json packages/sdk/editor-engine.json 2>/dev/null || true

          # Always include [skip ci] in commit message
          git commit -m "chore: bump version to $TAG_NAME [skip ci]"
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

      - name: Merge version branch to workflow branch and push
        id: merge_to_target
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          VERSION_BRANCH="${{ env.version_branch }}"

          git checkout "$WORKFLOW_BRANCH" || {
            echo "âŒ Failed to checkout workflow branch: $WORKFLOW_BRANCH"
            exit 1
          }

          # Merge version branch using --strategy=ours to preserve workflow branch content
          # --strategy=ours creates a merge commit in history but keeps the workflow branch's tree unchanged
          # This preserves git history and tag creation reference while keeping content unchanged
          VERSION_COMMIT=$(git rev-parse "$VERSION_BRANCH")

          # Merge with --strategy=ours - this records the merge in history but keeps workflow branch content
          git merge "$VERSION_BRANCH" --strategy=ours --no-edit -m "chore: merge version bump commit [skip ci]"

          # Store the version commit SHA for tag creation (from version branch, not the merge commit)
          # The tag will point to the version commit, but the workflow branch content remains unchanged
          echo "version_commit_sha=$VERSION_COMMIT" >> $GITHUB_OUTPUT

          # Push the workflow branch with merge commit (using GitHub App token for protected branches)
          git push origin "$WORKFLOW_BRANCH"

      - name: Create GitHub release
        id: create_release
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          TARGET_REF="${{ steps.merge_to_target.outputs.version_commit_sha }}"

          # Create release with auto-generated notes
          # Use --notes-start-tag to ensure we compare against the correct previous tag
          gh release create $TAG_NAME \
            --target $TARGET_REF \
            --title "$TAG_NAME" \
            --generate-notes \
            --notes-start-tag "$PREVIOUS_TAG" \
            --prerelease

          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare notification text
        id: notify
        run: |
          RELEASE_URL="${{ steps.create_release.outputs.release_url }}"
          VERSION="${{ steps.bump_version.outputs.tag_name }}"

          # Prepare notification text with newlines
          TEXT="ðŸ§ª **UAT Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n\nRelease has been created and deployment will be triggered automatically."
          echo "text=$TEXT" >> $GITHUB_OUTPUT

  uat-hotfix:
    needs: setup
    if: needs.setup.outputs.environment == 'uat' && needs.setup.outputs.release_type == 'hotfix'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      notification_text: ${{ steps.notify.outputs.text }}
    steps:
      - name: Validate branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"

          # Terminate if branch is 'main' to prevent accidental history override
          if [ "$WORKFLOW_BRANCH" = "main" ]; then
            echo "âŒ Error: Cannot execute UAT hotfix on 'main' branch. UAT hotfix must be executed from a hotfix branch."
            exit 1
          fi

      - name: Get GitHub App Access Token
        id: github-app-access-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
          owner: ${{ github.repository_owner }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          token: ${{ steps.github-app-access-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fetch and cache GitHub Releases
        run: |
          gh release list --limit 10 --json isPrerelease,tagName | jq '.' > /tmp/releases.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Find previous release tag
        id: previous_tag
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # For UAT hotfix: find the tag (UAT or PRD) that matches the current package.json version
          # The hotfix branch can be created from either:
          # 1. A UAT release tag (e.g., 1.2.3-rc.0) - hotfixing existing UAT release
          # 2. A production release tag (e.g., 1.2.3) - new hotfix from production
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          ALL_TAGS=$(jq -r '.[] | .tagName' /tmp/releases.json)
          PREVIOUS_TAG=$(echo "$ALL_TAGS" | grep -Fx "${CURRENT_VERSION}" | head -1)

          if [ -z "$PREVIOUS_TAG" ]; then
            echo "âŒ Error: No tag found matching package.json version ($CURRENT_VERSION)"
            echo "âŒ The hotfix branch must be created from a valid UAT or production release tag."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Store workflow execution branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          # Target branch for UAT hotfix merge (default: main, configurable for testing)
          TARGET_BRANCH="main"
          echo "workflow_branch=$WORKFLOW_BRANCH" >> $GITHUB_ENV
          echo "target_branch=$TARGET_BRANCH" >> $GITHUB_ENV

      - name: Squash commits and prepare for UAT hotfix
        run: |
          # For UAT hotfix: squash all commits in the hotfix branch BEFORE version changes
          # Find the base commit (the tag the hotfix branch was created from)
          BASE_TAG="${{ steps.previous_tag.outputs.previous_tag }}"

          # Ensure tags are fetched
          git fetch --tags origin || git fetch --tags

          # Resolve tag to commit SHA
          BASE_COMMIT=$(git rev-parse "$BASE_TAG" 2>/dev/null)

          if [ -z "$BASE_COMMIT" ]; then
            echo "âŒ Error: Could not resolve tag '$BASE_TAG' to a commit"
            echo "âŒ Make sure the tag exists and the hotfix branch was created from a valid release tag."
            exit 1
          fi

          # Reset soft to base commit (keeps all changes from hotfix commits staged)
          # This effectively squashes all commits between BASE_COMMIT and HEAD into staged changes
          git reset --soft "$BASE_COMMIT"

          # All changes from hotfix commits are now staged
          # Version changes will be made next, then staged and committed together

      - name: Bump version in memory
        id: bump_version
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          # UAT hotfix: Check if we're hotfixing an existing UAT release
          # The hotfix branch was created from a UAT release tag, so package.json should have -rc.X
          if [[ "$CURRENT_VERSION" == *"-rc."* ]]; then
            # Hotfix existing UAT release: increment prerelease number only
            # e.g., 1.2.3-rc.0 -> 1.2.3-rc.1
            NEW_VERSION=$(npm version prerelease --preid=rc --git-tag-version=false)
          else
            # New UAT hotfix from main or production: increment patch and add -rc.0
            # e.g., 1.2.3 -> 1.2.4-rc.0
            NEW_VERSION=$(npm version prepatch --preid=rc --git-tag-version=false)
          fi

          # Remove 'v' prefix if present
          TAG_NAME=$(echo $NEW_VERSION | sed 's/^v//')
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Execute replicate version script
        run: node ./.github/scripts/replicate-version.js

      - name: Commit and push version changes
        id: commit_version
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"

          # Stage version-related files (squashed commits are already staged from reset --soft)
          git add package.json packages/*/package.json packages/sdk/editor-engine.json 2>/dev/null || true

          # Always include [skip ci] in commit message
          git commit -m "chore: bump version to $TAG_NAME [skip ci]"
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

          # Force push since we squashed commits
          git push origin "$WORKFLOW_BRANCH" --force

      - name: Merge UAT hotfix to target branch
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          TARGET_BRANCH="${{ env.target_branch }}"

          # Fetch and checkout the target branch
          git fetch origin "$TARGET_BRANCH" || {
            echo "âŒ Failed to fetch target branch: $TARGET_BRANCH"
            exit 1
          }
          git checkout "$TARGET_BRANCH" || {
            echo "âŒ Failed to checkout target branch: $TARGET_BRANCH"
            exit 1
          }

          # Merge hotfix branch using --strategy=ours to preserve target branch content
          # --strategy=ours creates a merge commit in history but keeps the target branch's tree unchanged
          git merge "$WORKFLOW_BRANCH" --strategy=ours --no-edit -m "chore: merge version bump commit [skip ci]"

          # Push the target branch with merge commit (using GitHub App token for protected branches)
          git push origin "$TARGET_BRANCH"

      - name: Delete UAT hotfix branch
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          TARGET_BRANCH="${{ env.target_branch }}"

          # Checkout target branch first to avoid being on the branch we want to delete
          git checkout "$TARGET_BRANCH"

          # Delete remote branch
          git push origin --delete "$WORKFLOW_BRANCH" || echo "âš ï¸  Remote branch $WORKFLOW_BRANCH not found or already deleted"

          # Delete local branch
          git branch -D "$WORKFLOW_BRANCH" || echo "âš ï¸  Remote branch $WORKFLOW_BRANCH not found or already deleted"

      - name: Create GitHub release
        id: create_release
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          TARGET_REF="${{ steps.commit_version.outputs.commit_sha }}"

          # Create release with auto-generated notes
          # Use --notes-start-tag to ensure we compare against the correct previous tag
          gh release create $TAG_NAME \
            --target $TARGET_REF \
            --title "$TAG_NAME" \
            --generate-notes \
            --notes-start-tag "$PREVIOUS_TAG" \
            --prerelease

          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare notification text
        id: notify
        run: |
          RELEASE_URL="${{ steps.create_release.outputs.release_url }}"
          VERSION="${{ steps.bump_version.outputs.tag_name }}"

          # Prepare notification text with newlines
          TEXT="ðŸ§ª **UAT Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n\nRelease has been created and deployment will be triggered automatically."
          echo "text=$TEXT" >> $GITHUB_OUTPUT

  prd-release:
    needs: setup
    if: needs.setup.outputs.environment == 'prd'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      notification_text: ${{ steps.notify.outputs.text }}
    steps:
      - name: Get GitHub App Access Token
        id: github-app-access-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
          owner: ${{ github.repository_owner }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          token: ${{ steps.github-app-access-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fetch and cache GitHub Releases
        run: |
          gh release list --limit 10 --json isPrerelease,tagName | jq '.' > /tmp/releases.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Find previous release tag
        id: previous_tag
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # For PRD releases, always use the latest production release as previous tag
          PREVIOUS_TAG=$(jq -r '.[] | select(.isPrerelease == false) | .tagName' /tmp/releases.json | head -1)

          # Fail if no previous PRD release found (required for all PRD releases)
          if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" = "null" ]; then
            echo "âŒ Error: No PRD release found. A previous PRD release is required for all PRD releases."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Find UAT tag for checkout
        id: uat_tag
        run: |
          RELEASE_TYPE="${{ needs.setup.outputs.release_type }}"

          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # Get all UAT releases (prereleases)
          ALL_UAT_TAGS=$(jq -r '.[] | select(.isPrerelease == true) | .tagName' /tmp/releases.json)

          if [ -z "$ALL_UAT_TAGS" ]; then
            echo "âŒ Error: No UAT releases found. PRD releases must be created from UAT releases."
            exit 1
          fi

          # Find the appropriate UAT tag based on release type
          if [ "$RELEASE_TYPE" = "hotfix" ]; then
            # For hotfix PRD: find UAT tag with same minor version as previous PRD tag
            PREVIOUS_PRD_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
            PRD_MINOR=$(echo "$PREVIOUS_PRD_TAG" | cut -d. -f1,2)

            # Find UAT tags with same minor version (hotfix)
            PREVIOUS_TAG=$(echo "$ALL_UAT_TAGS" | while read tag; do
              UAT_MINOR=$(echo "$tag" | sed 's/-rc\.[0-9]\+$//' | cut -d. -f1,2)
              if [ "$UAT_MINOR" = "$PRD_MINOR" ]; then
                echo "$tag"
              fi
            done | head -1)
          else
            # For regular PRD: use latest UAT release
            PREVIOUS_TAG=$(echo "$ALL_UAT_TAGS" | head -1)
          fi

          if [ -z "$PREVIOUS_TAG" ]; then
            echo "âŒ Error: No matching UAT release found for $RELEASE_TYPE PRD release."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Store workflow execution branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          echo "workflow_branch=$WORKFLOW_BRANCH" >> $GITHUB_ENV

      - name: Checkout UAT tag for PRD release
        run: |
          UAT_TAG="${{ steps.uat_tag.outputs.previous_tag }}"
          git fetch --tags

          # Create a branch from the UAT tag (both regular and hotfix PRD releases)
          # We'll commit the version to this branch, then merge to workflow branch
          VERSION_BRANCH="prd-release-$(date +%s)"
          git checkout -b "$VERSION_BRANCH" "$UAT_TAG" || {
            echo "âŒ Failed to create branch from UAT tag: $UAT_TAG"
            exit 1
          }
          echo "version_branch=$VERSION_BRANCH" >> $GITHUB_ENV

      - name: Bump version in memory
        id: bump_version
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # PRD releases (both regular and hotfix): strip prerelease suffix
          # e.g., 1.3.0-rc.2 -> 1.3.0 (regular)
          # e.g., 1.2.3-rc.1 -> 1.2.3 (hotfix, patch already incremented in UAT)
          NEW_VERSION=$(npm version patch --git-tag-version=false)

          # Remove 'v' prefix if present
          TAG_NAME=$(echo $NEW_VERSION | sed 's/^v//')
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Execute replicate version script
        run: node ./.github/scripts/replicate-version.js

      - name: Commit version changes
        id: commit_version
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"

          # Stage version-related files
          git add package.json packages/*/package.json packages/sdk/editor-engine.json 2>/dev/null || true

          # Always include [skip ci] in commit message
          git commit -m "chore: bump version to $TAG_NAME [skip ci]"
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

      - name: Merge version branch to workflow branch and push
        id: merge_to_target
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          VERSION_BRANCH="${{ env.version_branch }}"

          # Fetch the workflow branch (we're currently on version branch from UAT tag)
          git fetch origin "$WORKFLOW_BRANCH" || {
            echo "âŒ Failed to fetch workflow branch: $WORKFLOW_BRANCH"
            exit 1
          }

          git checkout "$WORKFLOW_BRANCH" || {
            echo "âŒ Failed to checkout workflow branch: $WORKFLOW_BRANCH"
            exit 1
          }

          # Merge version branch using --strategy=ours to preserve workflow branch content
          # --strategy=ours creates a merge commit in history but keeps the workflow branch's tree unchanged
          # This preserves git history and tag creation reference while keeping content unchanged
          VERSION_COMMIT=$(git rev-parse "$VERSION_BRANCH")

          # Merge with --strategy=ours - this records the merge in history but keeps workflow branch content
          git merge "$VERSION_BRANCH" --strategy=ours --no-edit -m "chore: merge version bump commit [skip ci]"

          # Store the version commit SHA for tag creation (from version branch, not the merge commit)
          # The tag will point to the version commit, but the workflow branch content remains unchanged
          echo "version_commit_sha=$VERSION_COMMIT" >> $GITHUB_OUTPUT

          # Push the workflow branch with merge commit (using GitHub App token for protected branches)
          git push origin "$WORKFLOW_BRANCH"

      - name: Create GitHub release
        id: create_release
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          TARGET_REF="${{ steps.merge_to_target.outputs.version_commit_sha }}"

          # Create release with auto-generated notes
          # Use --notes-start-tag to ensure we compare against the correct previous tag
          gh release create $TAG_NAME \
            --target $TARGET_REF \
            --title "$TAG_NAME" \
            --generate-notes \
            --notes-start-tag "$PREVIOUS_TAG"

          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare notification text
        id: notify
        run: |
          RELEASE_URL="${{ steps.create_release.outputs.release_url }}"
          VERSION="${{ steps.bump_version.outputs.tag_name }}"

          # Prepare notification text with newlines
          TEXT="ðŸŽ‰ **Production Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n\nRelease has been created and deployment will be triggered automatically."
          echo "text=$TEXT" >> $GITHUB_OUTPUT

  notify-teams:
    needs: [setup, uat-regular, uat-hotfix, prd-release]
    if: needs.uat-regular.result == 'success' || needs.uat-hotfix.result == 'success' || needs.prd-release.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Notify Teams
        run: |
          # Get notification text from the job that succeeded (only one will have a value)
          TEXT="${{ needs.uat-regular.outputs.notification_text || needs.uat-hotfix.outputs.notification_text || needs.prd-release.outputs.notification_text }}"

          # Use jq to properly escape the text for JSON
          payload=$(echo "$TEXT" | jq -Rs '{text: .}')

          curl --request POST \
          --header "Content-Type: application/json" \
          --data "$payload" \
          "${{ secrets.TEAMS_RELEASE_HOOK_URL }}"
