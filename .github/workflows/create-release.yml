name: Create GitHub Release

on:
  pull_request_review:
    types: [submitted]

jobs:
  create-release:
    runs-on: ubuntu-latest
    # Only run when PR is approved
    if: github.event.review.state == 'approved'
    permissions:
      contents: write
      pull-requests: read
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      HEAD_REF: ${{ github.head_ref }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Check if release branch
        id: check_release_branch
        run: |
          if [[ "$HEAD_REF" == release/* ]]; then
            echo "is_release_branch=true" >> $GITHUB_OUTPUT
            echo "✅ Branch $HEAD_REF is a release branch"
          else
            echo "❌ Error: Branch $HEAD_REF is not a release branch"
            echo "This workflow is only for release branches (release/*)"
            exit 1
          fi

      - name: Check if PR is ready to merge
        id: check_merge_ready
        run: |
          # Get PR details to check merge requirements
          PR_INFO=$(gh pr view ${{ github.event.pull_request.number }} --json mergeable,mergeStateStatus,reviewDecision)
          MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable')
          MERGE_STATE=$(echo "$PR_INFO" | jq -r '.mergeStateStatus')
          REVIEW_DECISION=$(echo "$PR_INFO" | jq -r '.reviewDecision')

          echo "PR mergeable: $MERGEABLE"
          echo "Merge state: $MERGE_STATE"
          echo "Review decision: $REVIEW_DECISION"

          # Check if PR is ready to merge
          if [ "$MERGEABLE" = "MERGEABLE" ] && [ "$MERGE_STATE" = "CLEAN" ] && [ "$REVIEW_DECISION" = "APPROVED" ]; then
            echo "merge_ready=true" >> $GITHUB_OUTPUT
            echo "✅ PR is ready to merge and create release"
          else
            echo "❌ Error: PR is not ready to merge"
            echo "   - Mergeable: $MERGEABLE"
            echo "   - Merge State: $MERGE_STATE"
            echo "   - Review Decision: $REVIEW_DECISION"
            echo "Please ensure PR is approved and ready to merge before creating release"
            exit 1
          fi

      - name: Get PR information
        id: pr_info
        run: |
          # Get PR labels to determine release type
          PR_LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels -q '.labels[].name' | tr '\n' ' ')
          echo "pr_labels=$PR_LABELS" >> $GITHUB_OUTPUT

          # Check if it's UAT or PRD release
          if echo "$PR_LABELS" | grep -q "uat"; then
            echo "release_type=prerelease" >> $GITHUB_OUTPUT
            echo "is_uat=true" >> $GITHUB_OUTPUT
          elif echo "$PR_LABELS" | grep -q "prd"; then
            echo "release_type=latest" >> $GITHUB_OUTPUT
            echo "is_uat=false" >> $GITHUB_OUTPUT
          else
            echo "❌ Error: PR must have either 'uat' or 'prd' label"
            exit 1
          fi

      - name: Get release version
        id: version_info
        run: |
          # Get version from package.json in the release branch
          git checkout $HEAD_REF
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Create git tag name (remove 'v' prefix if present)
          TAG_NAME=$(echo $VERSION | sed 's/^v//')
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

          echo "Release version: $VERSION"
          echo "Tag name: $TAG_NAME"

      - name: Get previous version
        id: previous_version
        run: |
          # Get the most recent git tag as previous version
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$PREVIOUS_TAG" ]; then
            echo "No previous tags found, this appears to be the first release"
            echo "previous_tag=" >> $GITHUB_OUTPUT
          else
            echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
            echo "Previous tag: $PREVIOUS_TAG"
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          PREVIOUS_TAG="${{ steps.previous_version.outputs.previous_tag }}"
          CURRENT_TAG="${{ steps.version_info.outputs.tag_name }}"
          IS_UAT="${{ steps.pr_info.outputs.is_uat }}"

          # Get commits for the release notes
          if [ -z "$PREVIOUS_TAG" ]; then
            # First release - get all commits
            RELEASE_NOTES=$(git log --oneline --no-merges | head -20)
            CHANGELOG_RANGE="initial...$CURRENT_TAG"
          else
            # Get commits between previous tag and current HEAD
            RELEASE_NOTES=$(git log --oneline --no-merges ${PREVIOUS_TAG}..HEAD)
            CHANGELOG_RANGE="${PREVIOUS_TAG}...$CURRENT_TAG"
          fi

          # Transform the release title based on release type
          if [ "$IS_UAT" = "true" ]; then
            # UAT release: convert alfa to rc (e.g., 1.27.0-alfa.0 -> 1.27.0-rc.0)
            RELEASE_TITLE=$(echo "$CURRENT_TAG" | sed 's/-alfa\./-rc./')
          else
            # Production release: remove rc suffix (e.g., 1.27.0-rc.0 -> 1.27.0)
            RELEASE_TITLE=$(echo "$CURRENT_TAG" | sed 's/-rc\.[0-9]*$//')
          fi

          echo "release_title=$RELEASE_TITLE" >> $GITHUB_OUTPUT

          # Start building the release notes
          echo "$RELEASE_TITLE" > release_notes.md
          echo "" >> release_notes.md
          echo "What's Changed" >> release_notes.md

          if [ -n "$RELEASE_NOTES" ]; then
            # Format each commit line with proper indentation
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                echo "    $line" >> release_notes.md
              fi
            done <<< "$RELEASE_NOTES"
          else
            echo "    - No changes detected" >> release_notes.md
          fi

          # Add changelog link
          echo "" >> release_notes.md
          echo "Full Changelog: $CHANGELOG_RANGE" >> release_notes.md

          echo "Generated release notes:"
          cat release_notes.md

      - name: Create git tag
        run: |
          TAG_NAME="${{ steps.version_info.outputs.tag_name }}"
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git tag -a $TAG_NAME -m "Release $TAG_NAME"
          git push origin $TAG_NAME
          echo "Created and pushed tag: $TAG_NAME"

      - name: Create GitHub release
        id: create_release
        run: |
          TAG_NAME="${{ steps.version_info.outputs.tag_name }}"
          RELEASE_TYPE="${{ steps.pr_info.outputs.release_type }}"
          RELEASE_TITLE="${{ steps.release_notes.outputs.release_title }}"

          # Create the release using GitHub CLI
          if [ "$RELEASE_TYPE" = "prerelease" ]; then
            gh release create $TAG_NAME \
              --title "$RELEASE_TITLE" \
              --notes-file release_notes.md \
              --prerelease
          else
            gh release create $TAG_NAME \
              --title "$RELEASE_TITLE" \
              --notes-file release_notes.md
          fi

          # Get the release URL
          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "Created GitHub release: $RELEASE_URL"

      - name: Notify Teams
        run: |
          RELEASE_URL="${{ steps.create_release.outputs.release_url }}"
          VERSION="${{ steps.version_info.outputs.version }}"
          RELEASE_TYPE="${{ steps.pr_info.outputs.release_type }}"

          if [ "$RELEASE_TYPE" = "prerelease" ]; then
            TYPE_EMOJI="🧪"
            TYPE_TEXT="UAT"
          else
            TYPE_EMOJI="🎉"
            TYPE_TEXT="Production"
          fi

          payload=$(cat <<EOF
          {
              "text": "$TYPE_EMOJI **$TYPE_TEXT Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n**Branch:** $HEAD_REF\n\nRelease has been automatically created and is now available."
          }
          EOF
          )

          curl --request POST \
          --header "Content-Type: application/json" \
          --data "$payload" \
          "${{ secrets.TEAMS_RELEASE_HOOK_URL }}"
