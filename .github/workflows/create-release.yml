name: Create GitHub Release

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment (uat or prd)"
        required: true
        type: choice
        options:
          - uat
          - prd
      release_type:
        description: "Release type (regular or hotfix)"
        required: true
        type: choice
        options:
          - regular
          - hotfix
      engine_version:
        description: "Engine version to use (e.g., 2.15.latest) - optional (UAT regular only)"
        required: false
        type: string

env:
  NODE_VERSION: 22.x
  RELEASES_LIMIT: 10

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      environment: ${{ steps.prepare.outputs.environment }}
      release_type: ${{ steps.prepare.outputs.release_type }}
      engine_version: ${{ steps.prepare.outputs.engine_version }}
      target_branch: ${{ steps.prepare.outputs.target_branch }}
    steps:
      - name: Prepare release parameters
        id: prepare
        run: |
          # Extract values from inputs (workflow_dispatch) or use defaults (push for testing)
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            # Default values for testing (branch push trigger)
            ENVIRONMENT="uat"
          fi

          if [ -n "${{ github.event.inputs.release_type }}" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Default values for testing (branch push trigger)
            RELEASE_TYPE="regular"
          fi

          if [ -n "${{ github.event.inputs.engine_version }}" ]; then
            ENGINE_VERSION="${{ github.event.inputs.engine_version }}"
          else
            # Default empty for testing (branch push trigger)
            ENGINE_VERSION=""
          fi

          # Determine target branch based on environment and release type
          # UAT regular and PRD releases: target branch is main
          # UAT hotfix: target branch is main (but workflow branch is the hotfix branch)
          TARGET_BRANCH="main"

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "engine_version=$ENGINE_VERSION" >> $GITHUB_OUTPUT
          echo "target_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT

  uat-regular:
    needs: setup
    if: needs.setup.outputs.environment == 'uat' && needs.setup.outputs.release_type == 'regular'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      notification_text: ${{ steps.notify.outputs.text }}
    steps:
      - name: Validate branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          if [ "$WORKFLOW_BRANCH" != "$TARGET_BRANCH" ]; then
            echo "âŒ Error: UAT regular release must be executed from '$TARGET_BRANCH' branch. Current branch: '$WORKFLOW_BRANCH'"
            exit 1
          fi

          echo "workflow_branch=$WORKFLOW_BRANCH" >> $GITHUB_ENV

      - name: Get GitHub App Access Token
        id: github-app-access-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
          owner: ${{ github.repository_owner }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          token: ${{ steps.github-app-access-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fetch and cache GitHub Releases
        run: |
          gh release list --limit ${{ env.RELEASES_LIMIT }} --json isPrerelease,tagName | jq '.' > /tmp/releases.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Find previous release tag
        id: previous_tag
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # For UAT regular: always use the latest production release as previous tag
          PREVIOUS_TAG=$(jq -r '.[] | select(.isPrerelease == false) | .tagName' /tmp/releases.json | head -1)

          if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" = "null" ]; then
            echo "âŒ Error: No production release found. A previous production release is required for UAT regular releases."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Bump version in memory
        id: bump_version
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # UAT regular: add -rc.0 prefix (minor version already bumped in post-production step)
          # e.g., 1.3.0-alpha.0 -> 1.3.0-rc.0
          NEW_VERSION=$(npm version prerelease --preid=rc --git-tag-version=false)

          # Remove 'v' prefix if present
          TAG_NAME=$(echo $NEW_VERSION | sed 's/^v//')
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Execute replicate version script
        run: node ./.github/scripts/replicate-version.js

      - name: Update engine version
        if: needs.setup.outputs.engine_version != ''
        run: |
          ENGINE_VERSION="${{ needs.setup.outputs.engine_version }}"
          ENGINE_JSON="packages/sdk/editor-engine.json"

          # Update the engine version in editor-engine.json
          node -e "
            const fs = require('fs');
            const path = '$ENGINE_JSON';
            const data = JSON.parse(fs.readFileSync(path, 'utf8'));
            data.current = '$ENGINE_VERSION';
            fs.writeFileSync(path, JSON.stringify(data, null, 4));
          "

      - name: Commit version changes
        id: commit_version
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"

          # Create a version branch for the version commit
          VERSION_BRANCH="temp-release-$(date +%s)"
          git checkout -b "$VERSION_BRANCH"
          echo "version_branch=$VERSION_BRANCH" >> $GITHUB_ENV

          # Stage version-related files
          git add package.json packages/*/package.json packages/sdk/editor-engine.json 2>/dev/null || true

          # Always include [skip ci] in commit message
          git commit -m "chore: bump version to $TAG_NAME [skip ci]"
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

          # Store the version commit SHA for release creation
          VERSION_COMMIT=$(git rev-parse HEAD)
          echo "version_commit_sha=$VERSION_COMMIT" >> $GITHUB_OUTPUT

      - name: Create GitHub release
        id: create_release
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          TARGET_REF="${{ steps.commit_version.outputs.version_commit_sha }}"

          # Create release with auto-generated notes
          # Use --notes-start-tag to ensure we compare against the correct previous tag
          gh release create $TAG_NAME \
            --target $TARGET_REF \
            --title "$TAG_NAME" \
            --generate-notes \
            --notes-start-tag "$PREVIOUS_TAG" \
            --prerelease

          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge version branch to workflow branch and push
        id: merge_to_target
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          VERSION_BRANCH="${{ env.version_branch }}"

          git checkout "$WORKFLOW_BRANCH" || {
            echo "âŒ Failed to checkout workflow branch: $WORKFLOW_BRANCH"
            exit 1
          }

          # Merge version branch using --strategy=ours to preserve workflow branch content
          # --strategy=ours creates a merge commit in history but keeps the workflow branch's tree unchanged
          # This preserves git history and tag creation reference while keeping content unchanged
          # Merge with --strategy=ours - this records the merge in history but keeps workflow branch content
          git merge "$VERSION_BRANCH" --strategy=ours --no-edit -m "chore: merge version bump commit [skip ci]"

          # Push the workflow branch with merge commit (using GitHub App token for protected branches)
          git push origin "$WORKFLOW_BRANCH"

      - name: Prepare notification text
        id: notify
        run: |
          RELEASE_URL="${{ steps.create_release.outputs.release_url }}"
          VERSION="${{ steps.bump_version.outputs.tag_name }}"

          # Prepare notification text with newlines
          TEXT="ðŸ§ª **UAT Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n\nRelease has been created and deployment will be triggered automatically."
          echo "text=$TEXT" >> $GITHUB_OUTPUT

  uat-hotfix:
    needs: setup
    if: needs.setup.outputs.environment == 'uat' && needs.setup.outputs.release_type == 'hotfix'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      notification_text: ${{ steps.notify.outputs.text }}
    steps:
      - name: Validate branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          # Terminate if branch is the target branch to prevent accidental history override
          if [ "$WORKFLOW_BRANCH" = "$TARGET_BRANCH" ]; then
            echo "âŒ Error: Cannot execute UAT hotfix on 'main' branch. UAT hotfix must be executed from a hotfix branch."
            exit 1
          fi

      - name: Get GitHub App Access Token
        id: github-app-access-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
          owner: ${{ github.repository_owner }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          token: ${{ steps.github-app-access-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fetch and cache GitHub Releases
        run: |
          gh release list --limit ${{ env.RELEASES_LIMIT }} --json isPrerelease,tagName | jq '.' > /tmp/releases.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Store workflow execution branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          echo "workflow_branch=$WORKFLOW_BRANCH" >> $GITHUB_ENV

      - name: Find previous release tag
        id: previous_tag
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # For UAT hotfix: find the tag (UAT or PRD) that matches the current package.json version
          # The hotfix branch can be created from either:
          # 1. A UAT release tag (e.g., 1.2.3-rc.0) - hotfixing existing UAT release
          # 2. A production release tag (e.g., 1.2.3) - new hotfix from production
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          ALL_TAGS=$(jq -r '.[] | .tagName' /tmp/releases.json)
          PREVIOUS_TAG=$(echo "$ALL_TAGS" | grep -Fx "${CURRENT_VERSION}" | head -1)

          if [ -z "$PREVIOUS_TAG" ]; then
            echo "âŒ Error: No tag found matching package.json version ($CURRENT_VERSION)"
            echo "âŒ The hotfix branch must be created from a valid UAT or production release tag."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Bump version in memory
        id: bump_version
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          # UAT hotfix: Check if we're hotfixing an existing UAT release
          # The hotfix branch was created from a UAT release tag, so package.json should have -rc.X
          if [[ "$CURRENT_VERSION" == *"-rc."* ]]; then
            # Hotfix existing UAT release: increment prerelease number only
            # e.g., 1.2.3-rc.0 -> 1.2.3-rc.1
            NEW_VERSION=$(npm version prerelease --preid=rc --git-tag-version=false)
          else
            # New UAT hotfix from main or production: increment patch and add -rc.0
            # e.g., 1.2.3 -> 1.2.4-rc.0
            NEW_VERSION=$(npm version prepatch --preid=rc --git-tag-version=false)
          fi

          # Remove 'v' prefix if present
          TAG_NAME=$(echo $NEW_VERSION | sed 's/^v//')
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Execute replicate version script
        run: node ./.github/scripts/replicate-version.js

      - name: Commit and push version changes
        id: commit_version
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"

          # Stage version-related files
          git add package.json packages/*/package.json packages/sdk/editor-engine.json 2>/dev/null || true

          # Always include [skip ci] in commit message
          git commit -m "chore: bump version to $TAG_NAME [skip ci]"
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

          # Push version changes
          git push origin "$WORKFLOW_BRANCH"

      - name: Create GitHub release
        id: create_release_hotfix
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          TARGET_REF="${{ steps.commit_version.outputs.commit_sha }}"

          # Create release with auto-generated notes
          # Use --notes-start-tag to ensure we compare against the correct previous tag
          gh release create $TAG_NAME \
            --target $TARGET_REF \
            --title "$TAG_NAME" \
            --generate-notes \
            --notes-start-tag "$PREVIOUS_TAG" \
            --prerelease

          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge UAT hotfix to target branch
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          # Fetch and checkout the target branch
          git fetch origin "$TARGET_BRANCH" || {
            echo "âŒ Failed to fetch target branch: $TARGET_BRANCH"
            exit 1
          }
          git checkout "$TARGET_BRANCH" || {
            echo "âŒ Failed to checkout target branch: $TARGET_BRANCH"
            exit 1
          }

          # Merge hotfix branch using --strategy=ours to preserve target branch content
          # --strategy=ours creates a merge commit in history but keeps the target branch's tree unchanged
          git merge "$WORKFLOW_BRANCH" --strategy=ours --no-edit -m "chore: merge version bump commit [skip ci]"

          # Push the target branch with merge commit (using GitHub App token for protected branches)
          git push origin "$TARGET_BRANCH"

      - name: Delete UAT hotfix branch
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          # Checkout target branch first to avoid being on the branch we want to delete
          git checkout "$TARGET_BRANCH"

          # Delete remote branch
          git push origin --delete "$WORKFLOW_BRANCH" || echo "âš ï¸  Remote branch $WORKFLOW_BRANCH not found or already deleted"

          # Delete local branch
          git branch -D "$WORKFLOW_BRANCH" || echo "âš ï¸  Remote branch $WORKFLOW_BRANCH not found or already deleted"

      - name: Prepare notification text
        id: notify
        run: |
          RELEASE_URL="${{ steps.create_release_hotfix.outputs.release_url }}"
          VERSION="${{ steps.bump_version.outputs.tag_name }}"

          # Prepare notification text with newlines
          TEXT="ðŸ§ª **UAT Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n\nRelease has been created and deployment will be triggered automatically."
          echo "text=$TEXT" >> $GITHUB_OUTPUT

  production:
    needs: setup
    if: needs.setup.outputs.environment == 'prd'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      notification_text: ${{ steps.notify.outputs.text }}
    steps:
      - name: Validate branch
        run: |
          WORKFLOW_BRANCH="${{ github.ref_name }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          if [ "$WORKFLOW_BRANCH" != "$TARGET_BRANCH" ]; then
            echo "âŒ Error: PRD release must be executed from '$TARGET_BRANCH' branch. Current branch: '$WORKFLOW_BRANCH'"
              exit 1
          fi

          echo "workflow_branch=$WORKFLOW_BRANCH" >> $GITHUB_ENV

      - name: Get GitHub App Access Token
        id: github-app-access-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
          owner: ${{ github.repository_owner }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          token: ${{ steps.github-app-access-token.outputs.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Check cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fetch and cache GitHub Releases
        run: |
          gh release list --limit ${{ env.RELEASES_LIMIT }} --json isPrerelease,tagName | jq '.' > /tmp/releases.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate UAT tag exists
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # Read version from package.json (should match the UAT tag the branch was created from)
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          if [ -z "$CURRENT_VERSION" ]; then
            echo "âŒ Error: Could not read version from package.json"
            exit 1
          fi

          echo "ðŸ“¦ Current package.json version: $CURRENT_VERSION"

          # Check if this version exists as a UAT release (prerelease)
          UAT_TAG_EXISTS=$(jq -r --arg version "$CURRENT_VERSION" '.[] | select(.isPrerelease == true and .tagName == $version) | .tagName' /tmp/releases.json | head -1)

          if [ -z "$UAT_TAG_EXISTS" ] || [ "$UAT_TAG_EXISTS" = "null" ]; then
            echo "âŒ Error: UAT tag '$CURRENT_VERSION' not found in GitHub releases."
            echo "âŒ The workflow branch must be created from a valid UAT release tag."
            echo "âŒ Available UAT releases:"
            jq -r '.[] | select(.isPrerelease == true) | "  - \(.tagName)"' /tmp/releases.json || echo "  (none found)"
            exit 1
          fi

          echo "âœ… UAT tag '$CURRENT_VERSION' found in GitHub releases"

      - name: Find previous release tag
        id: previous_tag
        run: |
          if [ ! -f /tmp/releases.json ]; then
            echo "âŒ Error: Releases file not found"
            exit 1
          fi

          # For PRD releases, always use the latest production release as previous tag
          PREVIOUS_TAG=$(jq -r '.[] | select(.isPrerelease == false) | .tagName' /tmp/releases.json | head -1)

          # Fail if no previous PRD release found (required for all PRD releases)
          if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" = "null" ]; then
            echo "âŒ Error: No PRD release found. A previous PRD release is required for all PRD releases."
            exit 1
          fi

          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Bump version in memory
        id: bump_version
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # PRD releases (both regular and hotfix): strip prerelease suffix
          # e.g., 1.3.0-rc.2 -> 1.3.0 (regular)
          # e.g., 1.2.3-rc.1 -> 1.2.3 (hotfix, patch already incremented in UAT)
          NEW_VERSION=$(npm version patch --git-tag-version=false)

          # Remove 'v' prefix if present
          TAG_NAME=$(echo $NEW_VERSION | sed 's/^v//')
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Execute replicate version script
        run: node ./.github/scripts/replicate-version.js

      - name: Commit and push version changes
        id: commit_version
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"

          # Stage version-related files
          git add package.json packages/*/package.json packages/sdk/editor-engine.json 2>/dev/null || true

          # Always include [skip ci] in commit message
          git commit -m "chore: bump version to $TAG_NAME [skip ci]"
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "version_commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

          # Push version changes directly to workflow branch
          git push origin "$WORKFLOW_BRANCH"

      - name: Create GitHub release
        id: create_release
        run: |
          TAG_NAME="${{ steps.bump_version.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          TARGET_REF="${{ steps.commit_version.outputs.version_commit_sha }}"

          # Create release with auto-generated notes
          # Use --notes-start-tag to ensure we compare against the correct previous tag
          gh release create $TAG_NAME \
            --target $TARGET_REF \
            --title "$TAG_NAME" \
            --generate-notes \
            --notes-start-tag "$PREVIOUS_TAG"

          RELEASE_URL=$(gh release view $TAG_NAME --json url -q '.url')
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge release branch to target branch
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          # Fetch and checkout the target branch
          git fetch origin "$TARGET_BRANCH" || {
            echo "âŒ Failed to fetch target branch: $TARGET_BRANCH"
            exit 1
          }
          git checkout "$TARGET_BRANCH" || {
            echo "âŒ Failed to checkout target branch: $TARGET_BRANCH"
            exit 1
          }

          # Merge release branch using --strategy=ours to preserve target branch content
          # --strategy=ours creates a merge commit in history but keeps the target branch's tree unchanged
          git merge "$WORKFLOW_BRANCH" --strategy=ours --no-edit -m "chore: merge version bump commit [skip ci]"

          # Push the target branch with merge commit (using GitHub App token for protected branches)
          git push origin "$TARGET_BRANCH"

      - name: Delete workflow branch (release branch)
        run: |
          WORKFLOW_BRANCH="${{ env.workflow_branch }}"
          TARGET_BRANCH="${{ needs.setup.outputs.target_branch }}"

          # Checkout target branch first to avoid being on the branch we want to delete
          git checkout "$TARGET_BRANCH" || {
            echo "âš ï¸  Failed to checkout target branch: $TARGET_BRANCH. Attempting to delete workflow branch anyway."
          }

          # Delete remote workflow branch (release branch)
          git push origin --delete "$WORKFLOW_BRANCH" || echo "âš ï¸  Remote workflow branch $WORKFLOW_BRANCH not found or already deleted"

          # Delete local workflow branch (if still exists)
          git branch -D "$WORKFLOW_BRANCH" || echo "âš ï¸  Local workflow branch $WORKFLOW_BRANCH not found or already deleted"

      - name: Prepare notification text
        id: notify
        run: |
          RELEASE_URL="${{ steps.create_release.outputs.release_url }}"
          VERSION="${{ steps.bump_version.outputs.tag_name }}"

          # Prepare notification text with newlines
          TEXT="ðŸŽ‰ **Production Release Created**\n\n**Release:** $RELEASE_URL\n\n**Version:** $VERSION\n\nRelease has been created and deployment will be triggered automatically."
          echo "text=$TEXT" >> $GITHUB_OUTPUT

  notify-teams:
    needs: [setup, uat-regular, uat-hotfix, production]
    if: always() && (needs.uat-regular.result == 'success' || needs.uat-hotfix.result == 'success' || needs.production.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Extract notification text
        id: extract_text
        run: |
          # Get notification text from the job that succeeded (only one will have a value)
          # Check each job's result and get its notification text if it succeeded
          TEXT=""

          if [ "${{ needs.uat-regular.result }}" == "success" ]; then
            TEXT="${{ needs.uat-regular.outputs.notification_text }}"
          elif [ "${{ needs.uat-hotfix.result }}" == "success" ]; then
            TEXT="${{ needs.uat-hotfix.outputs.notification_text }}"
          elif [ "${{ needs.production.result }}" == "success" ]; then
            TEXT="${{ needs.production.outputs.notification_text }}"
          fi

          if [ -z "$TEXT" ]; then
            echo "âš ï¸  No notification text available. Skipping Teams notification."
            exit 0
          fi

          echo "text=$TEXT" >> $GITHUB_OUTPUT

      - name: Notify Teams
        run: |
          TEXT="${{ steps.extract_text.outputs.text }}"

          # Use jq to properly escape the text for JSON
          payload=$(echo "$TEXT" | jq -Rs '{text: .}')

          curl --request POST \
          --header "Content-Type: application/json" \
          --data "$payload" \
          "${{ secrets.TEAMS_RELEASE_HOOK_URL }}"
